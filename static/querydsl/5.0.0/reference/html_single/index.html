<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Querydsl Reference Guide</title><link rel="stylesheet" type="text/css" href="css/stylesheet.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Querydsl Reference Guide</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Timo</span> <span class="surname">Westk&auml;mper</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Samppa</span> <span class="surname">Saarela</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Vesa</span> <span class="surname">Marttila</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Lassi</span> <span class="surname">Immonen</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ruben</span> <span class="surname">Dijkstra</span></h3></div><div class="author"><h3 class="author"><span class="firstname">John</span> <span class="surname">Tims</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Robert</span> <span class="surname">Bain</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ido</span> <span class="surname">Salomon</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jan-Willem</span> <span class="surname">Gmelig Meyling</span></h3></div></div></div><div><p class="releaseinfo">5.0.0.M1</p></div><div><p class="copyright">Copyright &copy; 2007-2020 The Querydsl Team</p></div><div><div class="legalnotice"><a name="Legal_Notice"></a><p>
        This copyrighted material is made available to
        anyone wishing to use, modify, copy, or redistribute it subject to the terms and conditions of the
        <a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0" target="_top">Apache License, Version 2.0</a>.
    </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#intro">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e97">1.1. Background</a></span></dt><dt><span class="sect1"><a href="#d0e111">1.2. Principles</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorials">2. Tutorials</a></span></dt><dd><dl><dt><span class="sect1"><a href="#jpa_integration">2.1. Querying JPA</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e147">2.1.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e171">2.1.2. Ant integration</a></span></dt><dt><span class="sect2"><a href="#d0e189">2.1.3. Using Querydsl JPA in Roo</a></span></dt><dt><span class="sect2"><a href="#d0e211">2.1.4. Generating the model from hbm.xml files</a></span></dt><dt><span class="sect2"><a href="#d0e226">2.1.5. Using query types</a></span></dt><dt><span class="sect2"><a href="#d0e245">2.1.6. Querying</a></span></dt><dt><span class="sect2"><a href="#d0e317">2.1.7. Using joins</a></span></dt><dt><span class="sect2"><a href="#d0e336">2.1.8. General usage</a></span></dt><dt><span class="sect2"><a href="#d0e381">2.1.9. Ordering</a></span></dt><dt><span class="sect2"><a href="#d0e392">2.1.10. Grouping</a></span></dt><dt><span class="sect2"><a href="#d0e403">2.1.11. Delete clauses</a></span></dt><dt><span class="sect2"><a href="#d0e414">2.1.12. Update clauses</a></span></dt><dt><span class="sect2"><a href="#d0e425">2.1.13. Subqueries</a></span></dt><dt><span class="sect2"><a href="#d0e439">2.1.14. Exposing the original query</a></span></dt><dt><span class="sect2"><a href="#d0e446">2.1.15. Using Native SQL in JPA queries</a></span></dt></dl></dd><dt><span class="sect1"><a href="#jdo_integration">2.2. Querying JDO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e497">2.2.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e519">2.2.2. Ant integration</a></span></dt><dt><span class="sect2"><a href="#d0e537">2.2.3. Using query types</a></span></dt><dt><span class="sect2"><a href="#d0e560">2.2.4. Querying with JDO</a></span></dt><dt><span class="sect2"><a href="#d0e607">2.2.5. General usage</a></span></dt><dt><span class="sect2"><a href="#d0e647">2.2.6. Ordering</a></span></dt><dt><span class="sect2"><a href="#d0e654">2.2.7. Grouping</a></span></dt><dt><span class="sect2"><a href="#d0e661">2.2.8. Delete clauses</a></span></dt><dt><span class="sect2"><a href="#d0e670">2.2.9. Subqueries</a></span></dt><dt><span class="sect2"><a href="#d0e692">2.2.10. Using Native SQL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sql_integration">2.3. Querying SQL</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e731">2.3.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e740">2.3.2. Code generation via Maven</a></span></dt><dt><span class="sect2"><a href="#d0e1077">2.3.3. Code generation via ANT</a></span></dt><dt><span class="sect2"><a href="#d0e1089">2.3.4. Creating the query types</a></span></dt><dt><span class="sect2"><a href="#d0e1102">2.3.5. Configuration</a></span></dt><dt><span class="sect2"><a href="#d0e1163">2.3.6. Querying</a></span></dt><dt><span class="sect2"><a href="#d0e1190">2.3.7. General usage</a></span></dt><dt><span class="sect2"><a href="#d0e1235">2.3.8. Joins</a></span></dt><dt><span class="sect2"><a href="#d0e1250">2.3.9. Ordering</a></span></dt><dt><span class="sect2"><a href="#d0e1261">2.3.10. Grouping</a></span></dt><dt><span class="sect2"><a href="#d0e1273">2.3.11. Using Subqueries</a></span></dt><dt><span class="sect2"><a href="#d0e1287">2.3.12. Selecting literals</a></span></dt><dt><span class="sect2"><a href="#d0e1299">2.3.13. Query extension support</a></span></dt><dt><span class="sect2"><a href="#d0e1311">2.3.14. Window functions</a></span></dt><dt><span class="sect2"><a href="#d0e1323">2.3.15. Common table expressions</a></span></dt><dt><span class="sect2"><a href="#d0e1340">2.3.16. Other SQL expressions</a></span></dt><dt><span class="sect2"><a href="#d0e1348">2.3.17. Using Data manipulation commands</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e1351">2.3.17.1. Insert</a></span></dt><dt><span class="sect3"><a href="#d0e1396">2.3.17.2. Update</a></span></dt><dt><span class="sect3"><a href="#d0e1411">2.3.17.3. Delete</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e1422">2.3.18. Batch support in DML clauses</a></span></dt><dt><span class="sect2"><a href="#d0e1439">2.3.19. Bean class generation</a></span></dt><dt><span class="sect2"><a href="#d0e1451">2.3.20. Extracting the SQL query and bindings</a></span></dt><dt><span class="sect2"><a href="#d0e1460">2.3.21. Custom types</a></span></dt><dt><span class="sect2"><a href="#d0e1477">2.3.22. Listening to queries and clauses</a></span></dt><dt><span class="sect2"><a href="#d0e1484">2.3.23. Spring integration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#spatial">2.4. Querydsl Spatial</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1506">2.4.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e1517">2.4.2. Code generation via Maven</a></span></dt><dt><span class="sect2"><a href="#d0e1524">2.4.3. Runtime configuration</a></span></dt><dt><span class="sect2"><a href="#d0e1548">2.4.4. Querying</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e1553">2.4.4.1. Filter by Distance</a></span></dt><dt><span class="sect3"><a href="#d0e1560">2.4.4.2. Contains</a></span></dt><dt><span class="sect3"><a href="#d0e1565">2.4.4.3. Intersection</a></span></dt><dt><span class="sect3"><a href="#d0e1570">2.4.4.4. Access to the SPATIAL_REF_SYS table</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e1577">2.4.5. Inheritance</a></span></dt></dl></dd><dt><span class="sect1"><a href="#lucene_integration">2.5. Querying Lucene</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1589">2.5.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e1606">2.5.2. Creating the query types</a></span></dt><dt><span class="sect2"><a href="#d0e1617">2.5.3. Querying</a></span></dt><dt><span class="sect2"><a href="#d0e1628">2.5.4. General usage</a></span></dt><dt><span class="sect2"><a href="#d0e1660">2.5.5. Ordering</a></span></dt><dt><span class="sect2"><a href="#d0e1677">2.5.6. Limit</a></span></dt><dt><span class="sect2"><a href="#d0e1684">2.5.7. Offset</a></span></dt><dt><span class="sect2"><a href="#d0e1691">2.5.8. Fuzzy searches</a></span></dt><dt><span class="sect2"><a href="#d0e1701">2.5.9. Applying Lucene filters to queries</a></span></dt></dl></dd><dt><span class="sect1"><a href="#hibernate_search_integration">2.6. Querying Hibernate Search</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1717">2.6.1. Creating the Querydsl query types</a></span></dt><dt><span class="sect2"><a href="#d0e1725">2.6.2. Querying</a></span></dt><dt><span class="sect2"><a href="#d0e1732">2.6.3. General usage</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mongodb_integration">2.7. Querying Mongodb</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1750">2.7.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e1772">2.7.2. Querying</a></span></dt><dt><span class="sect2"><a href="#d0e1779">2.7.3. General usage</a></span></dt><dt><span class="sect2"><a href="#d0e1811">2.7.4. Ordering</a></span></dt><dt><span class="sect2"><a href="#d0e1820">2.7.5. Limit</a></span></dt><dt><span class="sect2"><a href="#d0e1827">2.7.6. Offset</a></span></dt><dt><span class="sect2"><a href="#d0e1834">2.7.7. Geospatial queries</a></span></dt><dt><span class="sect2"><a href="#d0e1841">2.7.8. Select only relevant fields</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections_integration">2.8. Querying Collections</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1855">2.8.1. Usage without generated query types</a></span></dt><dt><span class="sect2"><a href="#d0e1897">2.8.2. Usage with generated query types</a></span></dt><dt><span class="sect2"><a href="#d0e1906">2.8.3. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e1920">2.8.4. Ant integration</a></span></dt><dt><span class="sect2"><a href="#d0e1938">2.8.5. Hamcrest matchers</a></span></dt><dt><span class="sect2"><a href="#d0e1954">2.8.6. Usage with the Eclipse Compiler for Java</a></span></dt></dl></dd><dt><span class="sect1"><a href="#scala">2.9. Querying in Scala</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1968">2.9.1. DSL expressions for Scala</a></span></dt><dt><span class="sect2"><a href="#d0e1978">2.9.2. Querying with SQL</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e1991">2.9.2.1. Code generation</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e2000">2.9.3. Querying with other backends</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#general">3. General usage</a></span></dt><dd><dl><dt><span class="sect1"><a href="#creating_queries">3.1. Creating queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2053">3.1.1. Complex predicates</a></span></dt><dt><span class="sect2"><a href="#d0e2073">3.1.2. Dynamic expressions</a></span></dt><dt><span class="sect2"><a href="#d0e2096">3.1.3. Dynamic paths</a></span></dt><dt><span class="sect2"><a href="#d0e2140">3.1.4. Case expressions</a></span></dt><dt><span class="sect2"><a href="#d0e2156">3.1.5. Casting expressions</a></span></dt><dt><span class="sect2"><a href="#d0e2178">3.1.6. Select literals</a></span></dt></dl></dd><dt><span class="sect1"><a href="#result_handling">3.2. Result handling</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2208">3.2.1. Returning multiple columns</a></span></dt><dt><span class="sect2"><a href="#d0e2222">3.2.2. Bean population</a></span></dt><dt><span class="sect2"><a href="#d0e2233">3.2.3. Constructor usage</a></span></dt><dt><span class="sect2"><a href="#d0e2263">3.2.4. Result aggregation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#codegen">3.3. Code generation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2295">3.3.1. Path initialization</a></span></dt><dt><span class="sect2"><a href="#d0e2311">3.3.2. Customization</a></span></dt><dt><span class="sect2"><a href="#custom_types">3.3.3. Custom type mappings</a></span></dt><dt><span class="sect2"><a href="#d0e2529">3.3.4. Delegate methods</a></span></dt><dt><span class="sect2"><a href="#d0e2552">3.3.5. Non-annotated types</a></span></dt><dt><span class="sect2"><a href="#d0e2567">3.3.6. Classpath based code generation</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e2586">3.3.6.1. Usage via Maven</a></span></dt><dt><span class="sect3"><a href="#d0e2744">3.3.6.2. Scala support</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#alias">3.4. Alias usage</a></span></dt></dl></dd><dt><span class="chapter"><a href="#troubleshooting">4. Troubleshooting</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e2798">4.1. Insufficient type arguments</a></span></dt><dt><span class="sect1"><a href="#d0e2811">4.2. Multithreaded initialization of Querydsl Q-types</a></span></dt></dl></dd></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="preface"></a>Preface</h1></div></div></div><p>
    Querydsl is a framework which enables the construction of statically
    typed SQL-like queries. Instead of writing queries as inline strings or externalizing them
    into XML files they can be constructed via a fluent API like Querydsl.
  </p><p>
    The benefits of using a fluent API in comparison to simple strings are for example
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>code completion in IDE</p></li><li class="listitem"><p>almost none syntactically invalid queries allowed</p></li><li class="listitem"><p>domain types and properties can be referenced safely</p></li><li class="listitem"><p>adopts better to refactoring changes in domain types</p></li></ul></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="intro"></a>1.&nbsp;Introduction</h1></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e97"></a>1.1.&nbsp;Background</h2></div></div></div><p>
      Querydsl was born out of the need to maintain HQL queries in a typesafe way.       
      Incremental construction of HQL queries requires String concatenation and results
      in hard to read code. Unsafe references to domain types and properties
      via plain Strings were another issue with String based HQL construction.
    </p><p>
      With a changing domain model type-safety brings huge benefits in software
      development. Domain changes are directly reflected in queries and autocomplete in
      query construction makes query construction faster and safer.
    </p><p>
      HQL for Hibernate was the first target language for Querydsl, but nowadays it
      supports JPA, JDO, JDBC, Lucene, Hibernate Search, MongoDB, Collections and RDFBean
      as backends.
    </p><p>
      If you are completely new to database access in Java,<a class="ulink" href="https://www.marcobehler.com/guides/a-guide-to-accessing-databases-in-java" target="_top">https://www.marcobehler.com/guides/a-guide-to-accessing-databases-in-java</a> contains a good overview of the various parts, pieces and options and shows you where exactly QueryDSL fits in.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e111"></a>1.2.&nbsp;Principles</h2></div></div></div><p>
      <span class="emphasis"><em>Type safety</em></span>
      is the core principle of Querydsl. Queries are constructed based on generated query
      types that reflect the properties of your domain types. Also function/method
      invocations are constructed in a fully type-safe manner.
    </p><p>
      <span class="emphasis"><em>Consistency</em></span>
      is another important principle. The query paths and operations are the same
      in all implementations and also the Query interfaces have a common base interface.
    </p><p>
      To get an impression of the expressivity of the Querydsl query and expression types go to
      the javadocs and explore <code class="code">com.querydsl.core.Query</code>, <code class="code">com.querydsl.core.Fetchable</code>
      and <code class="code">com.querydsl.core.types.Expression</code>.
    </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="tutorials"></a>2.&nbsp;Tutorials</h1></div></div></div><p>
    Instead of a general Getting started guide we provide integration
    guides for the main backends of Querydsl.
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jpa_integration"></a>2.1.&nbsp;Querying JPA</h2></div></div></div><p>
    Querydsl defines a general statically typed syntax for querying on top of
    persisted domain model data. JDO and JPA are the primary integration
    technologies for Querydsl. This guide describes how to use Querydsl
    in combination with JPA.
  </p><p>
    Querydsl for JPA is an alternative to both JPQL and Criteria queries. It combines the
    dynamic nature of Criteria queries with the expressiveness of JPQL and all that in a fully
    typesafe manner.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e147"></a>2.1.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-apt<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-jpa<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>
      And now, configure the Maven APT plugin:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.mysema.maven<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>apt-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.1.3<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>process<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;outputDirectory&gt;</strong>target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/outputDirectory&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;processor&gt;</strong>com.querydsl.apt.jpa.JPAAnnotationProcessor<strong class="hl-tag" style="color: #000096">&lt;/processor&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
    ...
  <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>
      The JPAAnnotationProcessor finds domain types annotated with the
      javax.persistence.Entity annotation and generates query types for them.
    </p><p>
      If you use Hibernate annotations in your domain types you should use
      the APT processor
      <code class="code">com.querydsl.apt.hibernate.HibernateAnnotationProcessor</code>
      instead.
    </p><p>
      Run clean install and you will get your Query types generated into
      target/generated-sources/java.
    </p><p>
      If you use Eclipse, run mvn eclipse:eclipse to update your Eclipse project to
      include target/generated-sources/java as a source folder.
    </p><p>
      Now you are able to construct JPA query instances and instances of
      the query domain model.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e171"></a>2.1.2.&nbsp;Ant integration</h3></div></div></div><p>Place the jar files from the full-deps bundle on your classpath and use the
      following tasks for Querydsl code generation:
    </p><pre class="programlisting">
    <em class="hl-comment" style="color: silver">&lt;!-- APT based code generation --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;javac</strong> <span class="hl-attribute" style="color: #F5844C">srcdir</span>=<span class="hl-value" style="color: #993300">"${src}"</span> <span class="hl-attribute" style="color: #F5844C">classpathref</span>=<span class="hl-value" style="color: #993300">"cp"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"-proc:only"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"-processor"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"com.querydsl.apt.jpa.JPAAnnotationProcessor"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"-s"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${generated}"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/javac&gt;</strong>

    <em class="hl-comment" style="color: silver">&lt;!-- compilation --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;javac</strong> <span class="hl-attribute" style="color: #F5844C">classpathref</span>=<span class="hl-value" style="color: #993300">"cp"</span> <span class="hl-attribute" style="color: #F5844C">destdir</span>=<span class="hl-value" style="color: #993300">"${build}"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;src</strong> <span class="hl-attribute" style="color: #F5844C">path</span>=<span class="hl-value" style="color: #993300">"${src}"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;src</strong> <span class="hl-attribute" style="color: #F5844C">path</span>=<span class="hl-value" style="color: #993300">"${generated}"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/javac&gt;</strong>
</pre><p>
      Replace
      <span class="emphasis"><em>src</em></span>
      with your main source folder,
      <span class="emphasis"><em>generated</em></span>
      with your folder for generated sources
      and
      <span class="emphasis"><em>build</em></span>
      with your target folder.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e189"></a>2.1.3.&nbsp;Using Querydsl JPA in Roo</h3></div></div></div><p>
      If you are using Querydsl JPA with Spring Roo you can replace
      <code class="code">com.querydsl.apt.jpa.JPAAnnotationProcessor</code>
      with
      <code class="code">com.querydsl.apt.roo.RooAnnotationProcessor</code>
      which will handle
      <code class="code">@RooJpaEntity</code> and <code class="code">@RooJpaActiveRecord</code>
      annotated classes instead of
      <code class="code">@Entity</code>
      annotated classes.
    </p><p>
      APT based code generation doesn't work well with AspectJ IDTs.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e211"></a>2.1.4.&nbsp;Generating the model from hbm.xml files</h3></div></div></div><p>If you are using Hibernate with an XML based configuration, you can use the XML
      metadata to create your Querydsl model.
    </p><p><code class="code">com.querydsl.jpa.codegen.HibernateDomainExporter</code> provides the
      functionality for this:</p><pre class="programlisting">
HibernateDomainExporter exporter = <strong class="hl-keyword">new</strong> HibernateDomainExporter(
  <strong class="hl-string"><em style="color:red">"Q"</em></strong>,                     <em class="hl-comment" style="color: silver">// name prefix</em>
  <strong class="hl-keyword">new</strong> File(<strong class="hl-string"><em style="color:red">"target/gen3"</em></strong>), <em class="hl-comment" style="color: silver">// target folder</em>
  configuration);          <em class="hl-comment" style="color: silver">// instance of org.hibernate.cfg.Configuration</em>

exporter.export();
</pre><p>The HibernateDomainExporter needs to be executed within a classpath where the
      domain types are visible, since the property types are resolved
      via reflection.
    </p><p>All JPA annotations are ignored, but Querydsl annotations such as @QueryInit and
      @QueryType are taken into account.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e226"></a>2.1.5.&nbsp;Using query types</h3></div></div></div><p>
      To create queries with Querydsl you need to instantiate variables and
      Query implementations. We will start with the variables.
    </p><p>
      Let's assume that your project has the following domain type:
    </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Customer {
    <strong class="hl-keyword">private</strong> String firstName;
    <strong class="hl-keyword">private</strong> String lastName;

    <strong class="hl-keyword">public</strong> String getFirstName() {
        <strong class="hl-keyword">return</strong> firstName;
    }

    <strong class="hl-keyword">public</strong> String getLastName() {
        <strong class="hl-keyword">return</strong> lastName;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setFirstName(String fn) {
        firstName = fn;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setLastName(String ln) {
        lastName = ln;
    }
}
</pre><p>
      Querydsl will generate a query type with the simple name QCustomer into the
      same package as Customer. QCustomer can be used as a statically
      typed variable in Querydsl queries as a representative for the
      Customer type.
    </p><p>
      QCustomer has a default instance variable which can be accessed as a static
      field:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
</pre><p>
      Alternatively you can define your own Customer variables like this:
    </p><pre class="programlisting">
QCustomer customer = <strong class="hl-keyword">new</strong> QCustomer(<strong class="hl-string"><em style="color:red">"myCustomer"</em></strong>);
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e245"></a>2.1.6.&nbsp;Querying</h3></div></div></div><p>The Querydsl JPA module supports both the JPA and the Hibernate API.</p><p>
      To use the JPA API you use <code class="code">JPAQuery</code> instances for your queries like
      this:
    </p><pre class="programlisting">
<em class="hl-comment" style="color: silver">// where entityManager is a JPA EntityManager</em>
JPAQuery&lt;?&gt; query = <strong class="hl-keyword">new</strong> JPAQuery&lt;Void&gt;(entityManager);
</pre><p>If you are using the Hibernate API instead, you can instantiate a
    <code class="code">HibernateQuery</code> like this:
    </p><pre class="programlisting">
<em class="hl-comment" style="color: silver">// where session is a Hibernate session</em>
HibernateQuery&lt;?&gt; query = <strong class="hl-keyword">new</strong> HibernateQuery&lt;Void&gt;(session);
</pre><p>Both <code class="code">JPAQuery</code> and <code class="code">HibernateQuery</code> implement the <code class="code">JPQLQuery</code> interface.</p><p>For the examples of this chapter the queries are created via a <code class="code">JPAQueryFactory</code> instance.
      <code class="code">JPAQueryFactory</code> should be the preferred option to obtain <code class="code">JPAQuery</code> instances.</p><p>For the Hibernate API <code class="code">HibernateQueryFactory</code> can be used</p><p>
      To retrieve the customer with the first name Bob you would construct a
      query like this:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
Customer bob = queryFactory.selectFrom(customer)
  .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>))
  .fetchOne();
</pre><p>
      The selectFrom call defines the query source and projection, the where part defines the
      filter and fetchOne tells Querydsl to return a single element. Easy, right?
    </p><p>
      To create a query with multiple sources you use the query like this:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
QCompany company = QCompany.company;
query.from(customer, company);
</pre><p>
      And to use multiple filters use it like this
    </p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>), customer.lastName.eq(<strong class="hl-string"><em style="color:red">"Wilson"</em></strong>));
</pre><p>Or like this</p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>).and(customer.lastName.eq(<strong class="hl-string"><em style="color:red">"Wilson"</em></strong>)));
</pre><p>In native JPQL form the query would be written like this: </p><pre class="programlisting">
select customer from Customer as customer
where customer.firstName = "Bob" and customer.lastName = "Wilson"
</pre><p>If you want to combine the filters via "or" then use the following pattern
    </p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>).or(customer.lastName.eq(<strong class="hl-string"><em style="color:red">"Wilson"</em></strong>)));
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e317"></a>2.1.7.&nbsp;Using joins</h3></div></div></div><p>Querydsl supports the following join variants in JPQL: inner join, join, left
      join and right join. Join usage is typesafe, and follows the following pattern:
    </p><pre class="programlisting">
QCat cat = QCat.cat;
QCat mate = <strong class="hl-keyword">new</strong> QCat(<strong class="hl-string"><em style="color:red">"mate"</em></strong>);
QCat kitten = <strong class="hl-keyword">new</strong> QCat(<strong class="hl-string"><em style="color:red">"kitten"</em></strong>);
queryFactory.selectFrom(cat)
    .innerJoin(cat.mate, mate)
    .leftJoin(cat.kittens, kitten)
    .fetch();
</pre><p>The native JPQL version of the query would be </p><pre class="programlisting">
select cat from Cat as cat
inner join cat.mate as mate
left outer join cat.kittens as kitten
</pre><p>Another example</p><pre class="programlisting">
queryFactory.selectFrom(cat)
    .leftJoin(cat.kittens, kitten)
    .on(kitten.bodyWeight.gt(<span class="hl-number">10.0</span>))
    .fetch();
</pre><p>With the following JPQL version</p><pre class="programlisting">
select cat from Cat as cat
left join cat.kittens as kitten
on kitten.bodyWeight &gt; 10.0
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e336"></a>2.1.8.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the JPQLQuery interface like this</p><p>
      <span class="emphasis"><em>select:</em></span>
      Set the projection of the query. (Not necessary if created via query factory)
    </p><p>
      <span class="emphasis"><em>from:</em></span>
      Add the query sources here.
    </p><p>
      <span class="emphasis"><em>innerJoin, join, leftJoin, rightJoin, on:</em></span>
      Add join elements using these constructs.
      For the join methods the first argument is the join source and the second the target
      (alias).
    </p><p>
      <span class="emphasis"><em>where:</em></span>
      Add query filters, either in varargs form separated via commas or
      cascaded via the and-operator.
    </p><p>
      <span class="emphasis"><em>groupBy:</em></span>
      Add group by arguments in varargs form.
    </p><p>
      <span class="emphasis"><em>having:</em></span>
      Add having filters of the "group by" grouping as an varags array of
      Predicate expressions.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e381"></a>2.1.9.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
queryFactory.selectFrom(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.desc())
    .fetch();
</pre><p>which is equivalent to the following native JPQL</p><pre class="programlisting">
select customer from Customer as customer
order by customer.lastName asc, customer.firstName desc
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e392"></a>2.1.10.&nbsp;Grouping</h3></div></div></div><p>Grouping can be done in the following form</p><pre class="programlisting">
queryFactory.select(customer.lastName).from(customer)
    .groupBy(customer.lastName)
    .fetch();
</pre><p>which is equivalent to the following native JPQL</p><pre class="programlisting">
select customer.lastName
from Customer as customer
group by customer.lastName
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e403"></a>2.1.11.&nbsp;Delete clauses</h3></div></div></div><p>Delete clauses in Querydsl JPA follow a simple delete-where-execute form. Here
      are some
      examples:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
<em class="hl-comment" style="color: silver">// delete all customers</em>
queryFactory.delete(customer).execute();
<em class="hl-comment" style="color: silver">// delete all customers with a level less than 3</em>
queryFactory.delete(customer).where(customer.level.lt(<span class="hl-number">3</span>)).execute();
</pre><p>The where call is optional and the execute call performs the deletion and returns the
      amount of deleted entities.
    </p><p>DML clauses in JPA don't take JPA level cascade rules into account and don't provide
    fine-grained second level cache interaction.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e414"></a>2.1.12.&nbsp;Update clauses</h3></div></div></div><p>Update clauses in Querydsl JPA follow a simple update-set/where-execute form.
      Here are some examples:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
<em class="hl-comment" style="color: silver">// rename customers named Bob to Bobby</em>
queryFactory.update(customer).where(customer.name.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>))
    .set(customer.name, <strong class="hl-string"><em style="color:red">"Bobby"</em></strong>)
    .execute();
</pre><p>The set invocations define the property updates in SQL-Update-style and the execute call
      performs the Update and returns the amount of updated entities.
    </p><p>DML clauses in JPA don't take JPA level cascade rules into account and don't provide
    fine-grained second level cache interaction.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e425"></a>2.1.13.&nbsp;Subqueries</h3></div></div></div><p>To create a subquery you use the static factory methods of <code class="code">JPAExpressions</code> and
      define the query parameters via from, where etc.
    </p><pre class="programlisting">
QDepartment department = QDepartment.department;
QDepartment d = <strong class="hl-keyword">new</strong> QDepartment(<strong class="hl-string"><em style="color:red">"d"</em></strong>);
queryFactory.selectFrom(department)
    .where(department.size.eq(
        JPAExpressions.select(d.size.max()).from(d)))
     .fetch();
</pre><p>Another example</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
QEmployee e = <strong class="hl-keyword">new</strong> QEmployee(<strong class="hl-string"><em style="color:red">"e"</em></strong>);
queryFactory.selectFrom(employee)
    .where(employee.weeklyhours.gt(
        JPAExpressions.select(e.weeklyhours.avg())
            .from(employee.department.employees, e)
            .where(e.manager.eq(employee.manager))))
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e439"></a>2.1.14.&nbsp;Exposing the original query</h3></div></div></div><p>If you need to tune the original Query before the execution of the query you
      can expose it like this:
    </p><pre class="programlisting">
Query jpaQuery = queryFactory.selectFrom(employee).createQuery();
<em class="hl-comment" style="color: silver">// ...</em>
List results = jpaQuery.getResultList();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e446"></a>2.1.15.&nbsp;Using Native SQL in JPA queries</h3></div></div></div><p>Querydsl supports Native SQL in JPA via the JPASQLQuery class.
    </p><p>To use it, you must generate Querydsl query types for your SQL schema. This can
      be done for example with the following Maven configuration:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
      ...
      <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>export<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcDriver&gt;</strong>org.apache.derby.jdbc.EmbeddedDriver<strong class="hl-tag" style="color: #000096">&lt;/jdbcDriver&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcUrl&gt;</strong>jdbc:derby:target/demoDB;create=true<strong class="hl-tag" style="color: #000096">&lt;/jdbcUrl&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;packageName&gt;</strong>com.mycompany.mydomain<strong class="hl-tag" style="color: #000096">&lt;/packageName&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;targetFolder&gt;</strong>${project.basedir}/target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/targetFolder&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.derby<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>derby<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${derby.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
      ...
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>When the query types have successfully been generated into the location of your
      choice, you can use them in your queries.
    </p><p>Single column query:</p><pre class="programlisting">
<em class="hl-comment" style="color: silver">// serialization templates</em>
SQLTemplates templates = <strong class="hl-keyword">new</strong> DerbyTemplates();
<em class="hl-comment" style="color: silver">// query types (S* for SQL, Q* for domain types)</em>
SAnimal cat = <strong class="hl-keyword">new</strong> SAnimal(<strong class="hl-string"><em style="color:red">"cat"</em></strong>);
SAnimal mate = <strong class="hl-keyword">new</strong> SAnimal(<strong class="hl-string"><em style="color:red">"mate"</em></strong>);
QCat catEntity = QCat.cat;

JPASQLQuery&lt;?&gt; query = <strong class="hl-keyword">new</strong> JPASQLQuery&lt;Void&gt;(entityManager, templates);
List&lt;String&gt; names = query.select(cat.name).from(cat).fetch();
</pre><p>If you mix entity (e.g. QCat) and table (e.g. SAnimal) references in your query you need to make sure that they
    use the same variable names. SAnimal.animal has the variable name "animal", so a new instance
    (new SAnimal("cat")) was used instead.</p><p>An alternative pattern could be</p><pre class="programlisting">
QCat catEntity = QCat.cat;
SAnimal cat = <strong class="hl-keyword">new</strong> SAnimal(catEntity.getMetadata().getName());
</pre><p>Query multiple columns:</p><pre class="programlisting">
query = <strong class="hl-keyword">new</strong> JPASQLQuery&lt;Void&gt;(entityManager, templates);
List&lt;Tuple&gt; rows = query.select(cat.id, cat.name).from(cat).fetch();
</pre><p>Query all columns:</p><pre class="programlisting">
List&lt;Tuple&gt; rows = query.select(cat.all()).from(cat).fetch();
 </pre><p>Query in SQL, but project as entity: </p><pre class="programlisting">
query = <strong class="hl-keyword">new</strong> JPASQLQuery&lt;Void&gt;(entityManager, templates);
List&lt;Cat&gt; cats = query.select(catEntity).from(cat).orderBy(cat.name.asc()).fetch();
</pre><p>Query with joins: </p><pre class="programlisting">
query = <strong class="hl-keyword">new</strong> JPASQLQuery&lt;Void&gt;(entityManager, templates);
cats = query.select(catEntity).from(cat)
    .innerJoin(mate).on(cat.mateId.eq(mate.id))
    .where(cat.dtype.eq(<strong class="hl-string"><em style="color:red">"Cat"</em></strong>), mate.dtype.eq(<strong class="hl-string"><em style="color:red">"Cat"</em></strong>))
    .fetch();
</pre><p>Query and project into DTO: </p><pre class="programlisting">
query = <strong class="hl-keyword">new</strong> JPASQLQuery&lt;Void&gt;(entityManager, templates);
List&lt;CatDTO&gt; catDTOs = query.select(Projections.constructor(CatDTO.<strong class="hl-keyword">class</strong>, cat.id, cat.name))
    .from(cat)
    .orderBy(cat.name.asc())
    .fetch();
</pre><p>If you are using the Hibernate API instead of the JPA API, then use
      <code class="code">HibernateSQLQuery</code> instead.
    </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo_integration"></a>2.2.&nbsp;Querying JDO</h2></div></div></div><p>
    Querydsl defines a general statically typed syntax for querying on top of
    persisted domain model data. JDO and JPA are the primary integration
    technologies for
    Querydsl. This guide describes how to use Querydsl
    in combination with JDO.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e497"></a>2.2.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-apt<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-jdo<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>
      And now, configure the Maven APT plugin which generates the query types
      used by
      Querydsl:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
      ...
      <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.mysema.maven<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>apt-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.1.3<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>process<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;outputDirectory&gt;</strong>target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/outputDirectory&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;processor&gt;</strong>com.querydsl.apt.jdo.JDOAnnotationProcessor<strong class="hl-tag" style="color: #000096">&lt;/processor&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>
      The JDOAnnotationProcessor finds domain types annotated with the
      <code class="code">javax.jdo.annotations.PersistenceCapable</code> annotation and generates
      query types for them.
    </p><p>
      Run clean install and you will get your query types generated into
      target/generated-sources/java.
    </p><p>
      If you use Eclipse, run mvn eclipse:eclipse to update your Eclipse project to
      include target/generated-sources/java as a source folder.
    </p><p>
      Now you are able to construct JDO query instances and instances of the query domain model.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e519"></a>2.2.2.&nbsp;Ant integration</h3></div></div></div><p>Place the jar files from the full-deps bundle on your classpath and use the
      following tasks for Querydsl code generation:
    </p><pre class="programlisting">
    <em class="hl-comment" style="color: silver">&lt;!-- APT based code generation --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;javac</strong> <span class="hl-attribute" style="color: #F5844C">srcdir</span>=<span class="hl-value" style="color: #993300">"${src}"</span> <span class="hl-attribute" style="color: #F5844C">classpathref</span>=<span class="hl-value" style="color: #993300">"cp"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"-proc:only"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"-processor"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"com.querydsl.apt.jdo.JDOAnnotationProcessor"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"-s"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${generated}"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/javac&gt;</strong>

    <em class="hl-comment" style="color: silver">&lt;!-- compilation --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;javac</strong> <span class="hl-attribute" style="color: #F5844C">classpathref</span>=<span class="hl-value" style="color: #993300">"cp"</span> <span class="hl-attribute" style="color: #F5844C">destdir</span>=<span class="hl-value" style="color: #993300">"${build}"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;src</strong> <span class="hl-attribute" style="color: #F5844C">path</span>=<span class="hl-value" style="color: #993300">"${src}"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;src</strong> <span class="hl-attribute" style="color: #F5844C">path</span>=<span class="hl-value" style="color: #993300">"${generated}"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/javac&gt;</strong>
</pre><p>
      Replace
      <span class="emphasis"><em>src</em></span>
      with your main source folder,
      <span class="emphasis"><em>generated</em></span>
      with your folder for generated sources
      and
      <span class="emphasis"><em>build</em></span>
      with your target folder.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e537"></a>2.2.3.&nbsp;Using query types</h3></div></div></div><p>
      To create queries with Querydsl you need to instantiate variables and Query
      implementations. We will start with the variables.
    </p><p>
      Let's assume that your project has the following domain type:
    </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@PersistenceCapable</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Customer {
  <strong class="hl-keyword">private</strong> String firstName;
  <strong class="hl-keyword">private</strong> String lastName;

  <strong class="hl-keyword">public</strong> String getFirstName() {
    <strong class="hl-keyword">return</strong> firstName;
  }

  <strong class="hl-keyword">public</strong> String getLastName() {
    <strong class="hl-keyword">return</strong> lastName;
  }

  <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setFirstName(String fn) {
    firstName = fn;
  }

  <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setLastName(String ln) {
    lastName = ln;
  }
}
</pre><p>
      Querydsl will generate a query type with the simple name QCustomer into the
      same package as Customer. QCustomer can be used as a statically
      typed variable in Querydsl as a representative for the
      Customer type.
    </p><p>
      QCustomer has a default instance variable which can be accessed as a static
      field:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
</pre><p>
      Alternatively you can define your own Customer variables like this:
    </p><pre class="programlisting">
QCustomer customer = <strong class="hl-keyword">new</strong> QCustomer(<strong class="hl-string"><em style="color:red">"myCustomer"</em></strong>);
</pre><p>
      QCustomer reflects all the properties of the original type Customer as public
      fields. The firstName field can be accessed like this
    </p><pre class="programlisting">
customer.firstName;
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e560"></a>2.2.4.&nbsp;Querying with JDO</h3></div></div></div><p>
      For the JDO-module <code class="code">JDOQuery</code> is the main Query implementation. It
      is instantiated like this:
    </p><pre class="programlisting">
PersistenceManager pm = ...;
JDOQuery&lt;?&gt; query = <strong class="hl-keyword">new</strong> JDOQuery&lt;Void&gt;(pm);
</pre><p>For the examples of this chapter the queries are created via a <code class="code">JDOQueryFactory</code> instance.
    <code class="code">JDOQueryFactory</code> should be the preferred option to obtain <code class="code">JDOQuery</code> instances.</p><p>
      To retrieve the customer with the first name Bob you would construct a
      query like this:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
Customer bob = queryFactory.selectFrom(customer)
                   .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>))
                   .fetchOne();
</pre><p>
      The selectFrom call defines the query source and projection, the where part defines the
      filter and fetchOne tells Querydsl to return a single element. Easy, right?
    </p><p>Alternatively you can express it also like this</p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
Customer bob = queryFactory.select(customer).from(customer)
                   .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>))
                   .fetchOne();
</pre><p>
      To create a query with multiple sources you just use the JDOQuery class like this:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
QCompany company = QCompany.company;
query.from(customer, company);
</pre><p>
      And to use multiple filters use it like this
    </p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>), customer.lastName.eq(<strong class="hl-string"><em style="color:red">"Wilson"</em></strong>));
</pre><p>Or like this</p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>).and(customer.lastName.eq(<strong class="hl-string"><em style="color:red">"Wilson"</em></strong>)));
</pre><p>If you want to combine the filters via "or" then use the following pattern
    </p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>).or(customer.lastName.eq(<strong class="hl-string"><em style="color:red">"Wilson"</em></strong>)));
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e607"></a>2.2.5.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the JDOQuery class like this</p><p>
      <span class="emphasis"><em>select:</em></span>
      Set the projection of the query. (Not necessary if created via query factory)
    </p><p>
      <span class="emphasis"><em>from:</em></span>
      Add query sources here, the first argument becomes the main source
      and the others are treated as variables.
    </p><p>
      <span class="emphasis"><em>where:</em></span>
      Add query filters, either in varargs form separated via commas or
      cascaded via the and-operator.
    </p><p>
      <span class="emphasis"><em>groupBy:</em></span>
      Add group by arguments in varargs form.
    </p><p>
      <span class="emphasis"><em>having:</em></span>
      Add having filters of the "group by" grouping as an varargs array of
      Predicate expressions.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e647"></a>2.2.6.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
queryFactory.selectFrom(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.desc())
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e654"></a>2.2.7.&nbsp;Grouping</h3></div></div></div><p>Grouping can be done in the following form</p><pre class="programlisting">
queryFactory.select(customer.lastName).from(customer)
    .groupBy(customer.lastName)
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e661"></a>2.2.8.&nbsp;Delete clauses</h3></div></div></div><p>Delete clauses in Querydsl JDO follow a simple delete-where-execute form. Here
      are some examples:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
<em class="hl-comment" style="color: silver">// delete all customers</em>
queryFactory.delete(customer).execute();
<em class="hl-comment" style="color: silver">// delete all customers with a level less than 3</em>
queryFactory.delete(customer).where(customer.level.lt(<span class="hl-number">3</span>)).execute();
</pre><p>The second parameter of the JDODeleteClause constructor is the entity to be
      deleted. The where call is optional and the execute call performs the deletion and
      returns the amount of deleted entities.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e670"></a>2.2.9.&nbsp;Subqueries</h3></div></div></div><p>To create a subquery you can use one of the factory methods of <code class="code">JDOExpressions</code>
      and add the query parameters via from, where etc.
    </p><pre class="programlisting">
QDepartment department = QDepartment.department;
QDepartment d = <strong class="hl-keyword">new</strong> QDepartment(<strong class="hl-string"><em style="color:red">"d"</em></strong>);
queryFactory.selectFrom(department)
    .where(department.size.eq(JDOExpressions.select(d.size.max()).from(d))
    .fetch();
</pre><p>represents the following native JDO query</p><pre class="programlisting">
SELECT this FROM com.querydsl.jdo.models.company.Department
WHERE this.size ==
(SELECT max(d.size) FROM com.querydsl.jdo.models.company.Department d)
    </pre><p>Another example</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
QEmployee e = <strong class="hl-keyword">new</strong> QEmployee(<strong class="hl-string"><em style="color:red">"e"</em></strong>);
queryFactory.selectFrom(employee)
    .where(employee.weeklyhours.gt(
        JDOExpressions.select(e.weeklyhours.avg())
                      .from(employee.department.employees, e)
                      .where(e.manager.eq(employee.manager)))
    .fetch();
</pre><p>which represents the following native JDO query</p><pre class="programlisting">
SELECT this FROM com.querydsl.jdo.models.company.Employee
WHERE this.weeklyhours &gt;
(SELECT avg(e.weeklyhours) FROM this.department.employees e WHERE e.manager == this.manager)
    </pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e692"></a>2.2.10.&nbsp;Using Native SQL</h3></div></div></div><p>Querydsl supports Native SQL in JDO via the <code class="code">JDOSQLQuery</code> class.</p><p>To use it, you must generate Querydsl query types for your SQL schema. This can
      be done for example with the following Maven configuration:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
      ...
      <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>export<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcDriver&gt;</strong>org.apache.derby.jdbc.EmbeddedDriver<strong class="hl-tag" style="color: #000096">&lt;/jdbcDriver&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcUrl&gt;</strong>jdbc:derby:target/demoDB;create=true<strong class="hl-tag" style="color: #000096">&lt;/jdbcUrl&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;packageName&gt;</strong>com.mycompany.mydomain<strong class="hl-tag" style="color: #000096">&lt;/packageName&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;targetFolder&gt;</strong>${project.basedir}/target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/targetFolder&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.derby<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>derby<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${derby.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
      ...
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>When the query types have successfully been generated into the location of your
      choice, you can use them in your queries.
    </p><p>Single column query:</p><pre class="programlisting">
<em class="hl-comment" style="color: silver">// serialization templates</em>
SQLTemplates templates = <strong class="hl-keyword">new</strong> DerbyTemplates();
<em class="hl-comment" style="color: silver">// query types (S* for SQL, Q* for domain types)</em>
SAnimal cat = <strong class="hl-keyword">new</strong> SAnimal(<strong class="hl-string"><em style="color:red">"cat"</em></strong>);
SAnimal mate = <strong class="hl-keyword">new</strong> SAnimal(<strong class="hl-string"><em style="color:red">"mate"</em></strong>);

JDOSQLQuery&lt;?&gt; query = <strong class="hl-keyword">new</strong> JDOSQLQuery&lt;Void&gt;(pm, templates);
List&lt;String&gt; names = query.select(cat.name).from(cat).fetch();
</pre><p>Query multiple columns:</p><pre class="programlisting">
query = <strong class="hl-keyword">new</strong> JDOSQLQuery&lt;Void&gt;(pm, templates);
List&lt;Tuple&gt; rows = query.select(cat.id, cat.name).from(cat).fetch();
</pre><p>Query all columns:</p><pre class="programlisting">
List&lt;Tuple&gt; rows = query.select(cat.all()).from(cat).fetch();
 </pre><p>Query with joins: </p><pre class="programlisting">
query = <strong class="hl-keyword">new</strong> JDOSQLQuery&lt;Void&gt;(pm, templates);
cats = query.select(catEntity).from(cat)
    .innerJoin(mate).on(cat.mateId.eq(mate.id))
    .where(cat.dtype.eq(<strong class="hl-string"><em style="color:red">"Cat"</em></strong>), mate.dtype.eq(<strong class="hl-string"><em style="color:red">"Cat"</em></strong>))
    .fetch();
</pre><p>Query and project into DTO: </p><pre class="programlisting">
query = <strong class="hl-keyword">new</strong> JDOSQLQuery&lt;Void&gt;(pm, templates);
List&lt;CatDTO&gt; catDTOs = query.select(Projections.constructor(CatDTO.<strong class="hl-keyword">class</strong>, cat.id, cat.name))
    .from(cat)
    .orderBy(cat.name.asc())
    .fetch();
</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql_integration"></a>2.3.&nbsp;Querying SQL</h2></div></div></div><p>This chapter describes the query type generation and querying functionality of the
    SQL module.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e731"></a>2.3.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-sql<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-sql-codegen<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>The querydsl-sql-codegen dependency can be skipped, if code generation happens
      via Maven.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e740"></a>2.3.2.&nbsp;Code generation via Maven</h3></div></div></div><p>This functionality should be primarily used via the Maven plugin. Here is an example:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
      ...
      <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>export<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcDriver&gt;</strong>org.apache.derby.jdbc.EmbeddedDriver<strong class="hl-tag" style="color: #000096">&lt;/jdbcDriver&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcUrl&gt;</strong>jdbc:derby:target/demoDB;create=true<strong class="hl-tag" style="color: #000096">&lt;/jdbcUrl&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;packageName&gt;</strong>com.myproject.domain<strong class="hl-tag" style="color: #000096">&lt;/packageName&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;targetFolder&gt;</strong>${project.basedir}/target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/targetFolder&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.derby<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>derby<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${derby.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
      ...
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>
      Use the goal <span class="emphasis"><em>test-export</em></span>
      to treat the target folder as a test source folder for use with test code.
    </p><div class="table"><a name="d0e752"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Parameters</b></p><div class="table-contents"><table class="table" summary="Parameters" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col align="left" class="Name"><col align="left" class="Descriptions"></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Name</th><th style="border-bottom: 1px solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">jdbcDriver</td><td style="border-bottom: 1px solid ; " align="left">class name of the JDBC driver</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">jdbcUrl</td><td style="border-bottom: 1px solid ; " align="left">JDBC url</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">jdbcUser</td><td style="border-bottom: 1px solid ; " align="left">JDBC user</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">jdbcPassword</td><td style="border-bottom: 1px solid ; " align="left">JDBC password</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">namePrefix</td><td style="border-bottom: 1px solid ; " align="left">name prefix for generated query classes (default: Q)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">nameSuffix</td><td style="border-bottom: 1px solid ; " align="left">name suffix for generated query classes (default: )</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanPrefix</td><td style="border-bottom: 1px solid ; " align="left">name prefix for generated bean classes</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanSuffix</td><td style="border-bottom: 1px solid ; " align="left">name suffix for generated bean classes</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">packageName</td><td style="border-bottom: 1px solid ; " align="left">package name where source files should be generated</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanPackageName</td><td style="border-bottom: 1px solid ; " align="left">package name where bean files should be generated, (default:
              packageName)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanInterfaces</td><td style="border-bottom: 1px solid ; " align="left">array of interface classnames to add to the bean classes (default: empty)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanAddToString</td><td style="border-bottom: 1px solid ; " align="left">set to true to create a default toString() implementation (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanAddFullConstructor</td><td style="border-bottom: 1px solid ; " align="left">set to true to create a full constructor in addition to public empty (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanPrintSupertype</td><td style="border-bottom: 1px solid ; " align="left">set to true to print the supertype as well (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">schemaPattern</td><td style="border-bottom: 1px solid ; " align="left">a schema name pattern in LIKE pattern form; must match the schema name as it is stored in the database,
              multiple can be separated by comma
              (default: null)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">tableNamePattern</td><td style="border-bottom: 1px solid ; " align="left">a table name pattern in LIKE pattern form; must match the table name as it is stored in the database,
              multiple can be separated by comma
              (default: null)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">targetFolder</td><td style="border-bottom: 1px solid ; " align="left">target folder where sources should be generated</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beansTargetFolder</td><td style="border-bottom: 1px solid ; " align="left">target folder where bean sources should be generated, defaults to the same value as targetFolder</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">namingStrategyClass</td><td style="border-bottom: 1px solid ; " align="left">class name of the NamingStrategy class (default: DefaultNamingStrategy)
            </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanSerializerClass</td><td style="border-bottom: 1px solid ; " align="left">class name of the BeanSerializer class (default: BeanSerializer)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">serializerClass</td><td style="border-bottom: 1px solid ; " align="left">class name of the Serializer class (default: MetaDataSerializer)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportBeans</td><td style="border-bottom: 1px solid ; " align="left">set to true to generate beans as well, see section 2.14.13 (default:
              false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">innerClassesForKeys</td><td style="border-bottom: 1px solid ; " align="left">set to true to generate inner classes for keys (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">validationAnnotations</td><td style="border-bottom: 1px solid ; " align="left">set to true to enable serialization of validation annotations
              (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">columnAnnotations</td><td style="border-bottom: 1px solid ; " align="left">export column annotations (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">createScalaSources</td><td style="border-bottom: 1px solid ; " align="left">whether to export Scala sources instead of Java sources, (default:
              false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">schemaToPackage</td><td style="border-bottom: 1px solid ; " align="left">append schema name to package (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">lowerCase</td><td style="border-bottom: 1px solid ; " align="left">lower case transformation of names (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportTables</td><td style="border-bottom: 1px solid ; " align="left">export tables (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportViews</td><td style="border-bottom: 1px solid ; " align="left">export views (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportPrimaryKeys</td><td style="border-bottom: 1px solid ; " align="left">export primary keys (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">tableTypesToExport</td><td style="border-bottom: 1px solid ; " align="left">Comma-separated list of table types to export (allowable values will depend on JDBC driver).  Allows for arbitrary set of types to be exported, e.g.: "TABLE, MATERIALIZED VIEW". The exportTables and exportViews parameters will be ignored if this parameter is set. (default: none)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportForeignKeys</td><td style="border-bottom: 1px solid ; " align="left">export foreign keys (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportDirectForeignKeys</td><td style="border-bottom: 1px solid ; " align="left">export direct foreign keys (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportInverseForeignKeys</td><td style="border-bottom: 1px solid ; " align="left">export inverse foreign keys (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">customTypes</td><td style="border-bottom: 1px solid ; " align="left">Custom user types (default: none)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">typeMappings</td><td style="border-bottom: 1px solid ; " align="left">Mappings of table.column to Java type (default: none)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">numericMappings</td><td style="border-bottom: 1px solid ; " align="left">Mappings of size/digits to Java type (default: none)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">imports</td><td style="border-bottom: 1px solid ; " align="left">Array of java imports added to generated query classes: <span class="emphasis"><em>com.bar</em></span> for package (without .* notation), <span class="emphasis"><em>com.bar.Foo</em></span> for class (default: empty)</td></tr><tr><td style="border-right: 1px solid ; " align="left">generatedAnnotationClass</td><td style="" align="left">
              The fully qualified class name of the <span class="emphasis"><em>Single-Element Annotation</em></span> (with String element) to be added on the generated sources. Build in
              <span class="emphasis"><em>com.querydsl.core.annotations.Generated</em></span>has CLASS retention which can be used for byte code analysis tools like Jacoco.
              (default: <span class="emphasis"><em>javax.annotation.Generated</em></span> or<span class="emphasis"><em>javax.annotation.processing.Generated</em></span> depending on the java version). See also
              <a class="ulink" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7.3" target="_top">Single-Element Annotation</a>
            </td></tr></tbody></table></div></div><br class="table-break"><p>Custom types can be used to register additional Type implementations:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;customTypes&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;customType&gt;</strong>com.querydsl.sql.types.InputStreamType<strong class="hl-tag" style="color: #000096">&lt;/customType&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/customTypes&gt;</strong>
</pre><p>Type mappings can be used to register table.column specific java types:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;typeMappings&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;typeMapping&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;table&gt;</strong>IMAGE<strong class="hl-tag" style="color: #000096">&lt;/table&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;column&gt;</strong>CONTENTS<strong class="hl-tag" style="color: #000096">&lt;/column&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;type&gt;</strong>java.io.InputStream<strong class="hl-tag" style="color: #000096">&lt;/type&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/typeMapping&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/typeMappings&gt;</strong>
</pre><p>The defaults for the numeric mappings are </p><div class="table"><a name="d0e996"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Numeric mappings</b></p><div class="table-contents"><table class="table" summary="Numeric mappings" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col align="left" class="Name"><col align="left" class="Descriptions"><col></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Total digits</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Decimal digits</th><th style="border-bottom: 1px solid ; " align="left">Type</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">&gt; 18</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">0</td><td style="border-bottom: 1px solid ; " align="left">BigInteger</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">&gt; 9</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">0</td><td style="border-bottom: 1px solid ; " align="left">Long</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">&gt; 4</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">0</td><td style="border-bottom: 1px solid ; " align="left">Integer</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">&gt; 2</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">0</td><td style="border-bottom: 1px solid ; " align="left">Short</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">&gt; 0</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">0</td><td style="border-bottom: 1px solid ; " align="left">Byte</td></tr><tr><td style="border-right: 1px solid ; " align="left">&gt; 0</td><td style="border-right: 1px solid ; " align="left">&gt; 0</td><td style="" align="left">BigDecimal</td></tr></tbody></table></div></div><br class="table-break"><p>They can be customized for specific total/decimal digits combinations like this:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;numericMappings&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;numericMapping&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;total&gt;</strong>1<strong class="hl-tag" style="color: #000096">&lt;/total&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;decimal&gt;</strong>0<strong class="hl-tag" style="color: #000096">&lt;/decimal&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;javaType&gt;</strong>java.lang.Byte<strong class="hl-tag" style="color: #000096">&lt;/javaType&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/numericMapping&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/numericMappings&gt;</strong>
</pre><p>Imports can be used to add cross-schema foreign keys support.</p><p>Schemas, tables and columns can also be renamed using the plugin. Here are some examples:</p><p>Renaming a schema:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;renameMappings&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;renameMapping&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromSchema&gt;</strong>PROD<strong class="hl-tag" style="color: #000096">&lt;/fromSchema&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;toSchema&gt;</strong>TEST<strong class="hl-tag" style="color: #000096">&lt;/toSchema&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/renameMapping&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/renameMappings&gt;</strong>
</pre><p>Renaming a table:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;renameMappings&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;renameMapping&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromSchema&gt;</strong>PROD<strong class="hl-tag" style="color: #000096">&lt;/fromSchema&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromTable&gt;</strong>CUSTOMER<strong class="hl-tag" style="color: #000096">&lt;/fromTable&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;toTable&gt;</strong>CSTMR<strong class="hl-tag" style="color: #000096">&lt;/toTable&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/renameMapping&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/renameMappings&gt;</strong>
</pre><p>Renaming a column:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;renameMappings&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;renameMapping&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromSchema&gt;</strong>PROD<strong class="hl-tag" style="color: #000096">&lt;/fromSchema&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromTable&gt;</strong>CUSTOMER<strong class="hl-tag" style="color: #000096">&lt;/fromTable&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromColumn&gt;</strong>ID<strong class="hl-tag" style="color: #000096">&lt;/fromColumn&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;toColumn&gt;</strong>IDX<strong class="hl-tag" style="color: #000096">&lt;/toTable&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/renameMapping&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/renameMappings&gt;</strong>
</pre><p>Note: fromSchema can be omitted when renaming tables and columns.</p><p>Compared to APT based code generation certain functionality is not available such as QueryDelegate annotation handling.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1077"></a>2.3.3.&nbsp;Code generation via ANT</h3></div></div></div><p>
      The ANT task <code class="code">com.querydsl.sql.codegen.ant.AntMetaDataExporter</code>
      of the querydsl-sql module provides the same functionality as an ANT task.
      The configuration parameters of the task are the same as for the Maven plugin, except for the composite types.
    </p><p>
      The composite types are used without the wrapper element like in this example.
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"testproject"</span> <span class="hl-attribute" style="color: #F5844C">default</span>=<span class="hl-value" style="color: #993300">"codegen"</span> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

  <strong class="hl-tag" style="color: #000096">&lt;taskdef</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"codegen"</span> <span class="hl-attribute" style="color: #F5844C">classname</span>=<span class="hl-value" style="color: #993300">"com.querydsl.sql.codegen.ant.AntMetaDataExporter"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>

  <strong class="hl-tag" style="color: #000096">&lt;target</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"codegen"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;codegen</strong>
      <span class="hl-attribute" style="color: #F5844C">jdbcDriver</span>=<span class="hl-value" style="color: #993300">"org.h2.Driver"</span>
      <span class="hl-attribute" style="color: #F5844C">jdbcUser</span>=<span class="hl-value" style="color: #993300">"sa"</span>
      <span class="hl-attribute" style="color: #F5844C">jdbcUrl</span>=<span class="hl-value" style="color: #993300">"jdbc:h2:/dbs/db1"</span>
      <span class="hl-attribute" style="color: #F5844C">packageName</span>=<span class="hl-value" style="color: #993300">"test"</span>
      <span class="hl-attribute" style="color: #F5844C">targetFolder</span>=<span class="hl-value" style="color: #993300">"target/generated-sources/java"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;renameMapping</strong> <span class="hl-attribute" style="color: #F5844C">fromSchema</span>=<span class="hl-value" style="color: #993300">"PUBLIC"</span> <span class="hl-attribute" style="color: #F5844C">toSchema</span>=<span class="hl-value" style="color: #993300">"PUB"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/codegen&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/target&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1089"></a>2.3.4.&nbsp;Creating the query types</h3></div></div></div><p>To get started export your schema into Querydsl query types like this:</p><pre class="programlisting">
java.sql.Connection conn = ...;
MetaDataExporter exporter = <strong class="hl-keyword">new</strong> MetaDataExporter();
exporter.setPackageName(<strong class="hl-string"><em style="color:red">"com.myproject.mydomain"</em></strong>);
exporter.setTargetFolder(<strong class="hl-keyword">new</strong> File(<strong class="hl-string"><em style="color:red">"target/generated-sources/java"</em></strong>));
exporter.export(conn.getMetaData());
</pre><p>This declares that the database schema is to be mirrored into the
      com.myproject.domain package in the target/generated-sources/java folder.
    </p><p>
      The generated types have the table name transformed to mixed case as the class name and a
      similar mixed case transformation applied to the columns which are available as property
      paths in the query type.
    </p><p>
      In addition to this primary key and foreign key constraints are provided as fields
      which can be used for compact join declarations.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1102"></a>2.3.5.&nbsp;Configuration</h3></div></div></div><p>The configuration is done via the com.querydsl.sql.Configuration class which takes
      the
      Querydsl SQL dialect as an argument. For H2 you would create it like this</p><pre class="programlisting">
SQLTemplates templates = <strong class="hl-keyword">new</strong> H2Templates();
Configuration configuration = <strong class="hl-keyword">new</strong> Configuration(templates);
</pre><p>Querydsl uses SQL dialects to customize the SQL serialization needed for
      different relational databases. The available dialects are:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>CUBRIDTemplates (tested with CUBRID 8.4)</p></li><li class="listitem"><p>DB2Templates (tested with DB2 10.1.2)</p></li><li class="listitem"><p>DerbyTemplates (tested with Derby 10.8.2.2)</p></li><li class="listitem"><p>FirebirdTemplates (tested with Firebird 2.5)</p></li><li class="listitem"><p>HSQLDBTemplates (tested with HSQLDB 2.2.4)</p></li><li class="listitem"><p>H2Templates (tested with H2 1.3.164)</p></li><li class="listitem"><p>MySQLTemplates (tested with MySQL 5.5)</p></li><li class="listitem"><p>OracleTemplates (test with Oracle 10 and 11)</p></li><li class="listitem"><p>PostgreSQLTemplates (tested with PostgreSQL 9.1)</p></li><li class="listitem"><p>SQLiteTemplates (tested with xerial JDBC 3.7.2)</p></li><li class="listitem"><p>SQLServerTemplates (tested with SQL Server)</p></li><li class="listitem"><p>SQLServer2005Templates (for SQL Server 2005)</p></li><li class="listitem"><p>SQLServer2008Templates (for SQL Server 2008)</p></li><li class="listitem"><p>SQLServer2012Templates (for SQL Server 2012 and later)</p></li><li class="listitem"><p>TeradataTemplates (tested with Teradata 14)</p></li></ul></div><p>For customized SQLTemplates instances you can use the builder pattern like this</p><pre class="programlisting">
  H2Templates.builder()
     .printSchema() <em class="hl-comment" style="color: silver">// to include the schema in the output</em>
     .quote()       <em class="hl-comment" style="color: silver">// to quote names</em>
     .newLineToSingleSpace() <em class="hl-comment" style="color: silver">// to replace new lines with single space in the output</em>
     .escape(ch)    <em class="hl-comment" style="color: silver">// to set the escape char</em>
     .build();      <em class="hl-comment" style="color: silver">// to get the customized SQLTemplates instance</em>
</pre><p>The methods of the Configuration class can be used to enable direct serialization of literals
    via setUseLiterals(true), override schema and tables and register custom types. For full details look
    at the javadocs of Configuration.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1163"></a>2.3.6.&nbsp;Querying</h3></div></div></div><p>For the following examples we will be using the <code class="code">SQLQueryFactory</code> class for query creation.
      Using it results in more concise code compared to constructor based query creation.</p><pre class="programlisting">
SQLQueryFactory queryFactory = <strong class="hl-keyword">new</strong> SQLQueryFactory(configuration, dataSource);
</pre><p>Querying with Querydsl SQL is as simple as this:</p><pre class="programlisting">
QCustomer customer = <strong class="hl-keyword">new</strong> QCustomer(<strong class="hl-string"><em style="color:red">"c"</em></strong>);

List&lt;String&gt; lastNames = queryFactory.select(customer.lastName).from(customer)
    .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>))
    .fetch();
</pre><p>
      which is transformed into the following sql query, assuming that the related table
      name is <span class="emphasis"><em>customer</em></span>
      and the columns <span class="emphasis"><em>first_name</em></span>
      and <span class="emphasis"><em>last_name</em></span>:
    </p><pre class="programlisting">
SELECT c.last_name
FROM customer c
WHERE c.first_name = 'Bob'
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1190"></a>2.3.7.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the SQLQuery class like this</p><p>
      <span class="emphasis"><em>select:</em></span>
      Set the projection of the query. (Not necessary if created via query factory)
    </p><p>
      <span class="emphasis"><em>from:</em></span>
      Add the query sources here.
    </p><p>
      <span class="emphasis"><em>innerJoin, join, leftJoin, rightJoin, fullJoin, on:</em></span>
      Add join elements using these constructs.
      For the join methods the first argument is the join source and the second the target
      (alias).
    </p><p>
      <span class="emphasis"><em>where:</em></span>
      Add query filters, either in varargs form separated via commas or
      cascaded via the and-operator.
    </p><p>
      <span class="emphasis"><em>groupBy:</em></span>
      Add group by arguments in varargs form.
    </p><p>
      <span class="emphasis"><em>having:</em></span>
      Add having filter of the "group by" grouping as an varags array of
      Predicate expressions.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1235"></a>2.3.8.&nbsp;Joins</h3></div></div></div><p>Joins are constructed using the following syntax:</p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
QCompany company = QCompany.company;
queryFactory.select(customer.firstName, customer.lastName, company.name)
    .from(customer)
    .innerJoin(customer.company, company)
    .fetch();
</pre><p>and for a left join:</p><pre class="programlisting">
queryFactory.select(customer.firstName, customer.lastName, company.name)
    .from(customer)
    .leftJoin(customer.company, company)
    .fetch();
</pre><p>Alternatively the join condition can also be written out:</p><pre class="programlisting">
queryFactory.select(customer.firstName, customer.lastName, company.name)
    .from(customer)
    .leftJoin(company).on(customer.company.eq(company))
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1250"></a>2.3.9.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
queryFactory.select(customer.firstName, customer.lastName)
    .from(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.asc())
    .fetch();
</pre><p>which is equivalent to the following native SQL</p><pre class="programlisting">
SELECT c.first_name, c.last_name
FROM customer c
ORDER BY c.last_name ASC, c.first_name ASC
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1261"></a>2.3.10.&nbsp;Grouping</h3></div></div></div><p>Grouping can be done in the following form</p><pre class="programlisting">
queryFactory.select(customer.lastName)
    .from(customer)
    .groupBy(customer.lastName)
    .fetch();
</pre><p>which is equivalent to the following native SQL</p><pre class="programlisting">
SELECT c.last_name
FROM customer c
GROUP BY c.last_name
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1273"></a>2.3.11.&nbsp;Using Subqueries</h3></div></div></div><p>To create a subquery you can use one of the factory methods of <code class="code">SQLExpressions</code>
      and add the query parameters via from, where etc.
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
QCustomer customer2 = <strong class="hl-keyword">new</strong> QCustomer(<strong class="hl-string"><em style="color:red">"customer2"</em></strong>);
queryFactory.select(customer.all())
    .from(customer)
    .where(customer.status.eq(
        SQLExpressions.select(customer2.status.max()).from(customer2)))
    .fetch()
</pre><p>Another example</p><pre class="programlisting">
QStatus status = QStatus.status;
queryFactory.select(customer.all())
    .from(customer)
    .where(customer.status.in(
        SQLExpressions.select(status.id).from(status).where(status.level.lt(<span class="hl-number">3</span>))))
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1287"></a>2.3.12.&nbsp;Selecting literals</h3></div></div></div><p>To select literals you need to create constant instances for them like this:</p><pre class="programlisting">
queryFactory.select(Expressions.constant(<span class="hl-number">1</span>),
                    Expressions.constant(<strong class="hl-string"><em style="color:red">"abc"</em></strong>));
</pre><p>The class  <code class="code">com.querydsl.core.types.dsl.Expressions</code> offers also other useful static methods for
    projections, operation and template creation.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1299"></a>2.3.13.&nbsp;Query extension support</h3></div></div></div><p>Custom query extensions to support engine specific syntax can be created by
      subclassing AbstractSQLQuery and adding flagging methods like
      in the given MySQLQuery example:
    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MySQLQuery&lt;T&gt; <strong class="hl-keyword">extends</strong> AbstractSQLQuery&lt;T, MySQLQuery&lt;T&gt;&gt; {

    <strong class="hl-keyword">public</strong> MySQLQuery(Connection conn) {
        <strong class="hl-keyword">this</strong>(conn, <strong class="hl-keyword">new</strong> MySQLTemplates(), <strong class="hl-keyword">new</strong> DefaultQueryMetadata());
    }

    <strong class="hl-keyword">public</strong> MySQLQuery(Connection conn, SQLTemplates templates) {
        <strong class="hl-keyword">this</strong>(conn, templates, <strong class="hl-keyword">new</strong> DefaultQueryMetadata());
    }

    <strong class="hl-keyword">protected</strong> MySQLQuery(Connection conn, SQLTemplates templates, QueryMetadata metadata) {
        <strong class="hl-keyword">super</strong>(conn, <strong class="hl-keyword">new</strong> Configuration(templates), metadata);
    }

    <strong class="hl-keyword">public</strong> MySQLQuery bigResult() {
        <strong class="hl-keyword">return</strong> addFlag(Position.AFTER_SELECT, <strong class="hl-string"><em style="color:red">"SQL_BIG_RESULT "</em></strong>);
    }

    <strong class="hl-keyword">public</strong> MySQLQuery bufferResult() {
        <strong class="hl-keyword">return</strong> addFlag(Position.AFTER_SELECT, <strong class="hl-string"><em style="color:red">"SQL_BUFFER_RESULT "</em></strong>);
    }


    <em class="hl-comment" style="color: silver">// ...</em>
}
</pre><p>
      The flags are custom SQL snippets that can be inserted at specific points in the
      serialization. The supported positions are the enums of the
      <code class="code">com.querydsl.core.QueryFlag.Position</code> enum class.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1311"></a>2.3.14.&nbsp;Window functions</h3></div></div></div><p>Window functions are supported in Querydsl via the methods in the <code class="code">SQLExpressions</code> class.</p><p>Usage example:</p><pre class="programlisting">
queryFactory.select(SQLExpressions.rowNumber()
        .over()
        .partitionBy(employee.name)
        .orderBy(employee.id))
     .from(employee)
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1323"></a>2.3.15.&nbsp;Common table expressions</h3></div></div></div><p>Common table expressions are supported in Querydsl SQL via two syntax variants</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
queryFactory.with(employee, SQLExpressions.select(employee.all)
                                          .from(employee)
                                          .where(employee.name.startsWith(<strong class="hl-string"><em style="color:red">"A"</em></strong>)))
            .from(...)
</pre><p>And using a column listing</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
queryFactory.with(employee, employee.id, employee.name)
            .as(SQLExpressions.select(employee.id, employee.name)
                              .from(employee)
                              .where(employee.name.startsWith(<strong class="hl-string"><em style="color:red">"A"</em></strong>)))
            .from(...)
</pre><p>If the columns of the common table expression are a subset of an existing table or view
    it is advisable to use a generated path type for it, e.g. QEmployee in this case, but if the
    columns don't fit any existing table PathBuilder can be used instead.</p><p>Below is an example for such a case</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
QDepartment department = QDepartment.department;
PathBuilder&lt;Tuple&gt; emp = <strong class="hl-keyword">new</strong> PathBuilder&lt;Tuple&gt;(Tuple.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"emp"</em></strong>);
queryFactory.with(emp, SQLExpressions.select(employee.id, employee.name, employee.departmentId,
                                          department.name.as(<strong class="hl-string"><em style="color:red">"departmentName"</em></strong>))
                                      .from(employee)
                                      .innerJoin(department).on(employee.departmentId.eq(department.id))))
            .from(...)
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1340"></a>2.3.16.&nbsp;Other SQL expressions</h3></div></div></div><p>
    Other SQL expressions are also available from the <code class="code">SQLExpressions</code> class as static methods.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1348"></a>2.3.17.&nbsp;Using Data manipulation commands</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1351"></a>2.3.17.1.&nbsp;Insert</h4></div></div></div><p>With columns</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.insert(survey)
    .columns(survey.id, survey.name)
    .values(<span class="hl-number">3</span>, <strong class="hl-string"><em style="color:red">"Hello"</em></strong>).execute();
</pre><p>Without columns</p><pre class="programlisting">
queryFactory.insert(survey)
    .values(<span class="hl-number">4</span>, <strong class="hl-string"><em style="color:red">"Hello"</em></strong>).execute();
</pre><p>With subquery</p><pre class="programlisting">
queryFactory.insert(survey)
    .columns(survey.id, survey.name)
    .select(SQLExpressions.select(survey2.id.add(<span class="hl-number">1</span>), survey2.name).from(survey2))
    .execute();
</pre><p>With subquery, without columns</p><pre class="programlisting">
queryFactory.insert(survey)
    .select(SQLExpressions.select(survey2.id.add(<span class="hl-number">10</span>), survey2.name).from(survey2))
    .execute();
</pre><p>As an alternative to the columns/values usage, Querydsl provides also a set
     method which can be used like this</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.insert(survey)
    .set(survey.id, <span class="hl-number">3</span>)
    .set(survey.name, <strong class="hl-string"><em style="color:red">"Hello"</em></strong>).execute();
</pre><p>which is equivalent to the first example. Usage of the set method always
     expands internally to columns and values.</p><p>Beware that</p><pre class="programlisting">
columns(...).select(...)
</pre><p>maps the result set of the given query to be inserted whereas</p><p>To get the created keys out instead of modified rows count use one of the executeWithKey/s method.</p><pre class="programlisting">
set(...)
</pre><p>maps single columns and nulls are used for empty subquery results.</p><p>To populate a clause instance based on the contents of a bean you can use</p><pre class="programlisting">
queryFactory.insert(survey)
    .populate(surveyBean).execute();
</pre><p>This will exclude null bindings, if you need also null bindings use</p><pre class="programlisting">
queryFactory.insert(survey)
    .populate(surveyBean, DefaultMapper.WITH_NULL_BINDINGS).execute();
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1396"></a>2.3.17.2.&nbsp;Update</h4></div></div></div><p>With where</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.update(survey)
    .where(survey.name.eq(<strong class="hl-string"><em style="color:red">"XXX"</em></strong>))
    .set(survey.name, <strong class="hl-string"><em style="color:red">"S"</em></strong>)
    .execute();
</pre><p>Without where</p><pre class="programlisting">
queryFactory.update(survey)
    .set(survey.name, <strong class="hl-string"><em style="color:red">"S"</em></strong>)
    .execute();
</pre><p>Using bean population</p><pre class="programlisting">
queryFactory.update(survey)
    .populate(surveyBean)
    .execute();
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1411"></a>2.3.17.3.&nbsp;Delete</h4></div></div></div><p>With where</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.delete(survey)
    .where(survey.name.eq(<strong class="hl-string"><em style="color:red">"XXX"</em></strong>))
    .execute();

</pre><p>Without where</p><pre class="programlisting">
queryFactory.delete(survey)
    .execute()
</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1422"></a>2.3.18.&nbsp;Batch support in DML clauses</h3></div></div></div><p>Querydsl SQL supports usage of JDBC batch updates through the DML APIs. If you
      have consecutive DML calls with a similar structure,
      you can bundle the the calls via addBatch() usage into one DMLClause. See the examples how
      it works for UPDATE, DELETE and INSERT.
    </p><p>Update:</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.insert(survey).values(<span class="hl-number">2</span>, <strong class="hl-string"><em style="color:red">"A"</em></strong>).execute();
queryFactory.insert(survey).values(<span class="hl-number">3</span>, <strong class="hl-string"><em style="color:red">"B"</em></strong>).execute();

SQLUpdateClause update = queryFactory.update(survey);
update.set(survey.name, <strong class="hl-string"><em style="color:red">"AA"</em></strong>).where(survey.name.eq(<strong class="hl-string"><em style="color:red">"A"</em></strong>)).addBatch();
update.set(survey.name, <strong class="hl-string"><em style="color:red">"BB"</em></strong>).where(survey.name.eq(<strong class="hl-string"><em style="color:red">"B"</em></strong>)).addBatch();
</pre><p>Delete:</p><pre class="programlisting">
queryFactory.insert(survey).values(<span class="hl-number">2</span>, <strong class="hl-string"><em style="color:red">"A"</em></strong>).execute();
queryFactory.insert(survey).values(<span class="hl-number">3</span>, <strong class="hl-string"><em style="color:red">"B"</em></strong>).execute();

SQLDeleteClause delete = queryFactory.delete(survey);
delete.where(survey.name.eq(<strong class="hl-string"><em style="color:red">"A"</em></strong>)).addBatch();
delete.where(survey.name.eq(<strong class="hl-string"><em style="color:red">"B"</em></strong>)).addBatch();
assertEquals(<span class="hl-number">2</span>, delete.execute());
</pre><p>Insert:</p><pre class="programlisting">
SQLInsertClause insert = queryFactory.insert(survey);
insert.set(survey.id, <span class="hl-number">5</span>).set(survey.name, <strong class="hl-string"><em style="color:red">"5"</em></strong>).addBatch();
insert.set(survey.id, <span class="hl-number">6</span>).set(survey.name, <strong class="hl-string"><em style="color:red">"6"</em></strong>).addBatch();
assertEquals(<span class="hl-number">2</span>, insert.execute());
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1439"></a>2.3.19.&nbsp;Bean class generation</h3></div></div></div><p>To create JavaBean DTO types for the tables of your schema use the
      MetaDataExporter like this:</p><pre class="programlisting">
java.sql.Connection conn = ...;
MetaDataExporter exporter = <strong class="hl-keyword">new</strong> MetaDataExporter();
exporter.setPackageName(<strong class="hl-string"><em style="color:red">"com.myproject.mydomain"</em></strong>);
exporter.setTargetFolder(<strong class="hl-keyword">new</strong> File(<strong class="hl-string"><em style="color:red">"src/main/java"</em></strong>));
exporter.setBeanSerializer(<strong class="hl-keyword">new</strong> BeanSerializer());
exporter.export(conn.getMetaData());
</pre><p>Now you can use the bean types as arguments to the populate method in DML
      clauses and you can project directly
      to bean types in queries. Here is a simple example in JUnit form:
    </p><pre class="programlisting">
QEmployee e = <strong class="hl-keyword">new</strong> QEmployee(<strong class="hl-string"><em style="color:red">"e"</em></strong>);

<em class="hl-comment" style="color: silver">// Insert</em>
Employee employee = <strong class="hl-keyword">new</strong> Employee();
employee.setFirstname(<strong class="hl-string"><em style="color:red">"John"</em></strong>);
Integer id = queryFactory.insert(e).populate(employee).executeWithKey(e.id);
employee.setId(id);

<em class="hl-comment" style="color: silver">// Update</em>
employee.setLastname(<strong class="hl-string"><em style="color:red">"Smith"</em></strong>);
assertEquals(<span class="hl-number">1l</span>, queryFactory.update(e).populate(employee).where(e.id.eq(employee.getId())).execute());

<em class="hl-comment" style="color: silver">// Query</em>
Employee smith = queryFactory.selectFrom(e).where(e.lastname.eq(<strong class="hl-string"><em style="color:red">"Smith"</em></strong>)).fetchOne();
assertEquals(<strong class="hl-string"><em style="color:red">"John"</em></strong>, smith.getFirstname());

<em class="hl-comment" style="color: silver">// Delete</em>
assertEquals(<span class="hl-number">1l</span>, queryFactory.delete(e).where(e.id.eq(employee.getId())).execute());
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1451"></a>2.3.20.&nbsp;Extracting the SQL query and bindings</h3></div></div></div><p>The SQL query and bindings can be extracted via the getSQL method:</p><pre class="programlisting">
SQLBindings bindings = query.getSQL();
System.out.println(bindings.getSQL());
</pre><p>If you need also all literals in the SQL string you can enable literal serialization on the
   query or configuration level via setUseLiterals(true).</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1460"></a>2.3.21.&nbsp;Custom types</h3></div></div></div><p>Querydsl SQL provides the possibility to declare custom type mappings for
      ResultSet/Statement interaction. The custom type mappings can be
      declared in com.querydsl.sql.Configuration instances, which are supplied as constructor
      arguments to the actual queries:
    </p><pre class="programlisting">
Configuration configuration = <strong class="hl-keyword">new</strong> Configuration(<strong class="hl-keyword">new</strong> H2Templates());
<em class="hl-comment" style="color: silver">// overrides the mapping for Types.DATE</em>
configuration.register(<strong class="hl-keyword">new</strong> UtilDateType());
</pre><p>And for a table column</p><pre class="programlisting">
Configuration configuration = <strong class="hl-keyword">new</strong> Configuration(<strong class="hl-keyword">new</strong> H2Templates());
<em class="hl-comment" style="color: silver">// declares a mapping for the gender column in the person table</em>
configuration.register(<strong class="hl-string"><em style="color:red">"person"</em></strong>, <strong class="hl-string"><em style="color:red">"gender"</em></strong>,  <strong class="hl-keyword">new</strong> EnumByNameType&lt;Gender&gt;(Gender.<strong class="hl-keyword">class</strong>));
</pre><p>To customize a numeric mapping you can use the registerNumeric method like this
    </p><pre class="programlisting">
configuration.registerNumeric(<span class="hl-number">5</span>,<span class="hl-number">2</span>,Float.<strong class="hl-keyword">class</strong>);
</pre><p>This will map the Float type to the NUMERIC(5,2) type.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1477"></a>2.3.22.&nbsp;Listening to queries and clauses</h3></div></div></div><p>SQLListener is a listener interface that can be used to listen to queries and DML clause. SQLListener
    instances can be registered either on the configuration and on the query/clause level via the addListener method.</p><p>Use cases for listeners are data synchronization, logging, caching and validation.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1484"></a>2.3.23.&nbsp;Spring integration</h3></div></div></div><p>Querydsl SQL integrates with Spring through the querydsl-sql-spring module:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-sql-spring<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>It provides Spring exception translation and a Spring connection provider for usage of Querydsl SQL
    with Spring transaction managers. Below is a configuration example:</p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.querydsl.example.config;

<strong class="hl-keyword">import</strong> com.querydsl.sql.H2Templates;
<strong class="hl-keyword">import</strong> com.querydsl.sql.SQLQueryFactory;
<strong class="hl-keyword">import</strong> com.querydsl.sql.SQLTemplates;
<strong class="hl-keyword">import</strong> com.querydsl.sql.spring.SpringConnectionProvider;
<strong class="hl-keyword">import</strong> com.querydsl.sql.spring.SpringExceptionTranslator;
<strong class="hl-keyword">import</strong> com.querydsl.sql.types.DateTimeType;
<strong class="hl-keyword">import</strong> com.querydsl.sql.types.LocalDateType;
<strong class="hl-keyword">import</strong> org.springframework.context.annotation.Bean;
<strong class="hl-keyword">import</strong> org.springframework.context.annotation.Configuration;
<strong class="hl-keyword">import</strong> org.springframework.context.annotation.PropertySource;
<strong class="hl-keyword">import</strong> org.springframework.core.env.Environment;
<strong class="hl-keyword">import</strong> org.springframework.jdbc.datasource.DataSourceTransactionManager;
<strong class="hl-keyword">import</strong> org.springframework.transaction.PlatformTransactionManager;

<strong class="hl-keyword">import</strong> javax.sql.DataSource;
<strong class="hl-keyword">import</strong> java.sql.Connection;

<em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> JdbcConfiguration {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <strong class="hl-keyword">public</strong> DataSource dataSource() {
        <em class="hl-comment" style="color: silver">// implementation omitted</em>
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <strong class="hl-keyword">public</strong> PlatformTransactionManager transactionManager() {
        <strong class="hl-keyword">return</strong> <strong class="hl-keyword">new</strong> DataSourceTransactionManager(dataSource());
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <strong class="hl-keyword">public</strong> com.querydsl.sql.Configuration querydslConfiguration() {
        SQLTemplates templates = H2Templates.builder().build(); <em class="hl-comment" style="color: silver">//change to your Templates</em>
        com.querydsl.sql.Configuration configuration = <strong class="hl-keyword">new</strong> com.querydsl.sql.Configuration(templates);
        configuration.setExceptionTranslator(<strong class="hl-keyword">new</strong> SpringExceptionTranslator());
        <strong class="hl-keyword">return</strong> configuration;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <strong class="hl-keyword">public</strong> SQLQueryFactory queryFactory() {
        SpringConnectionProvider provider = <strong class="hl-keyword">new</strong> SpringConnectionProvider(dataSource());
        <strong class="hl-keyword">return</strong> <strong class="hl-keyword">new</strong> SQLQueryFactory(querydslConfiguration(), provider);
    }

}
</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spatial"></a>2.4.&nbsp;Querydsl Spatial</h2></div></div></div><p>Support for Spatial queries is available via the Querydsl Spatial module, which is an extension
  module to the SQL module. The Spatial module supports the object model of Simple Feature Access in queries
  and object binding.</p><p>The <a class="ulink" href="http://www.geolatte.org/" target="_top">geolatte</a> project is used for the object model.</p><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="90%"><tr><td><img src="media/spatial.svg" width="100%"></td></tr></table><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1506"></a>2.4.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependency to your Maven project:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-sql-spatial<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>Additionally the following database specific extra dependencies:</p><pre class="programlisting">
<em class="hl-comment" style="color: silver">&lt;!-- for PostgreSQL usage --&gt;</em>
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.postgis<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>postgis-jdbc<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.3.3<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>

<em class="hl-comment" style="color: silver">&lt;!-- for Oracle usage --&gt;</em>
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>oracle<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>sdoapi<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>11.2.0<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1517"></a>2.4.2.&nbsp;Code generation via Maven</h3></div></div></div><p>The code generation for Querydsl SQL can be set to detect the usage of spatial types in
    database schemas and use geolatte types in these case via the spatial property:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
      ...
      <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        ...
        <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
          ...
          <strong class="hl-tag" style="color: #000096">&lt;spatial&gt;</strong>true<strong class="hl-tag" style="color: #000096">&lt;/spatial&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
      ...
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1524"></a>2.4.3.&nbsp;Runtime configuration</h3></div></div></div><p>The runtime configuration aspect of the spatial module is that instead of the normal
    SQLTemplates instances, spatial enabled instances are used. Below is a list of spatial enabled
    SQLTemplates classes.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GeoDBTemplates (for H2)</p></li><li class="listitem"><p>MySQLSpatialTemplates</p></li><li class="listitem"><p>OracleSpatialTemplates (alpha stage)</p></li><li class="listitem"><p>PostGISTemplates</p></li><li class="listitem"><p>SQLServer2008SpatialTemplates</p></li><li class="listitem"><p>TeradataSpatialTemplates</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1548"></a>2.4.4.&nbsp;Querying</h3></div></div></div><p>With code generation and runtime configuration set for spatial types we can now try
    queries with it.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1553"></a>2.4.4.1.&nbsp;Filter by Distance</h4></div></div></div><pre class="programlisting">
Geometry point = Wkt.fromWkt(<strong class="hl-string"><em style="color:red">"Point(2 2)"</em></strong>);
query.where(table.geo.distance(point).lt(<span class="hl-number">5.0</span>));
</pre><p>In addition to straight distance between geometries spherical and spheroidal distance are provided via
      distanceSphere and distanceSpheroid.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1560"></a>2.4.4.2.&nbsp;Contains</h4></div></div></div><pre class="programlisting">
Geometry point = Wkt.fromWkt(<strong class="hl-string"><em style="color:red">"Point(2 2)"</em></strong>);
query.where(table.geo.contains(point));
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1565"></a>2.4.4.3.&nbsp;Intersection</h4></div></div></div><pre class="programlisting">
Geometry geo = query.select(table.geo1.intersection(table.geo2)).fetchOne();
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1570"></a>2.4.4.4.&nbsp;Access to the SPATIAL_REF_SYS table</h4></div></div></div><p>Unified access to the SPATIAL_REF_SYS standard table is provided via the QSpatialRefSys
      and SpatialRefSys classes. SPATIAL_REF_SYS contains data about the supported spatial reference systems.</p><pre class="programlisting">
QSpatialRefSys spatialRefSys = QSpatialRefSys.spatialRefSys;
List&lt;SpatialRefSys&gt; referenceSystems = query.select(spatialRefSys).from(spatialRefSys).fetch();
</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1577"></a>2.4.5.&nbsp;Inheritance</h3></div></div></div><p>In case you use only generic geometry types in your database schema you can use conversion methods
    in the object model to convert to more specific types.</p><pre class="programlisting">
GeometryPath&lt;Geometry&gt; geometry = shapes.geometry;
PointPath&lt;Point&gt; point = geometry.asPoint();
NumberExpression&lt;Double&gt; pointX = point.x(); <em class="hl-comment" style="color: silver">// x() is not available on GeometryExpression/GeometryPath</em>
</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lucene_integration"></a>2.5.&nbsp;Querying Lucene</h2></div></div></div><p>This chapter describes the querying functionality of the Lucene module.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1589"></a>2.5.1.&nbsp;Maven integration</h3></div></div></div><p>
      Querydsl Lucene can be used via the querydsl-lucene3 module for Lucene 3, querydsl-lucene4
      for Lucene 4 and querydsl-lucene5 for Lucene 5
    </p><p>Lucene 3:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-lucene3<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>Lucene 4:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-lucene4<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>Lucene 5:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-lucene5<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1606"></a>2.5.2.&nbsp;Creating the query types</h3></div></div></div><p>With fields year and title a manually created query type could look something
      like this:</p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> QDocument <strong class="hl-keyword">extends</strong> EntityPathBase&lt;Document&gt; {
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">final</strong> <strong class="hl-keyword">long</strong> serialVersionUID = -<span class="hl-number">4872833626508344081L</span>;

    <strong class="hl-keyword">public</strong> QDocument(String var) {
        <strong class="hl-keyword">super</strong>(Document.<strong class="hl-keyword">class</strong>, PathMetadataFactory.forVariable(var));
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">final</strong> StringPath year = createString(<strong class="hl-string"><em style="color:red">"year"</em></strong>);

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">final</strong> StringPath title = createString(<strong class="hl-string"><em style="color:red">"title"</em></strong>);
}
</pre><p>QDocument represents a Lucene document with the fields year and title.</p><p>Code generation is not available for Lucene, since no schema data is available.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1617"></a>2.5.3.&nbsp;Querying</h3></div></div></div><p>Querying with Querydsl Lucene is as simple as this:</p><pre class="programlisting">
QDocument doc = <strong class="hl-keyword">new</strong> QDocument(<strong class="hl-string"><em style="color:red">"doc"</em></strong>);

IndexSearcher searcher = <strong class="hl-keyword">new</strong> IndexSearcher(index);
LuceneQuery query = <strong class="hl-keyword">new</strong> LuceneQuery(true, searcher);
List&lt;Document&gt; documents = query
    .where(doc.year.between(<strong class="hl-string"><em style="color:red">"1800"</em></strong>, <strong class="hl-string"><em style="color:red">"2000"</em></strong>).and(doc.title.startsWith(<strong class="hl-string"><em style="color:red">"Huckle"</em></strong>))
    .fetch();
</pre><p>which is transformed into the following Lucene query:</p><pre class="programlisting">
+year:[1800 TO 2000] +title:huckle*
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1628"></a>2.5.4.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the LuceneQuery class like this</p><p>
      <span class="emphasis"><em>where:</em></span>
      Add the query filters, either in varargs form separated via commas or
      cascaded via the and-operator. Supported operations are operations performed on PStrings except
      <span class="emphasis"><em>
        matches
      </em></span>
      ,
      <span class="emphasis"><em>indexOf</em></span>
      ,
      <span class="emphasis"><em>charAt</em></span>
      . Currently
      <span class="emphasis"><em>in</em></span>
      is
      not supported, but will be in the future.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1660"></a>2.5.5.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
query
    .where(doc.title.like(<strong class="hl-string"><em style="color:red">"*"</em></strong>))
    .orderBy(doc.title.asc(), doc.year.desc())
    .fetch();
</pre><p>which is equivalent to the following Lucene query</p><pre class="programlisting">
title:*
</pre><p>The results are sorted ascending based on title and year.</p><p>Alternatively a sort method call can be used to declare the sort logic as a Sort
      instance instead
    </p><pre class="programlisting">
Sort sort = ...;
query
    .where(doc.title.like(<strong class="hl-string"><em style="color:red">"*"</em></strong>))
    .sort(sort)
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1677"></a>2.5.6.&nbsp;Limit</h3></div></div></div><p>The syntax for declaring a limit is </p><pre class="programlisting">
query
    .where(doc.title.like(<strong class="hl-string"><em style="color:red">"*"</em></strong>))
    .limit(<span class="hl-number">10</span>)
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1684"></a>2.5.7.&nbsp;Offset</h3></div></div></div><p>The syntax for declaring an offset is </p><pre class="programlisting">
query
    .where(doc.title.like(<strong class="hl-string"><em style="color:red">"*"</em></strong>))
    .offset(<span class="hl-number">3</span>)
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1691"></a>2.5.8.&nbsp;Fuzzy searches</h3></div></div></div><p>Fuzzy searches can be expressed via fuzzyLike methods in the
      <code class="code">com.querydsl.lucene3.LuceneExpressions</code> class:
    </p><pre class="programlisting">
query
    .where(LuceneExpressions.fuzzyLike(doc.title, <strong class="hl-string"><em style="color:red">"Hello"</em></strong>))
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1701"></a>2.5.9.&nbsp;Applying Lucene filters to queries</h3></div></div></div><p>It is possible to apply a single Lucene filter to the query like this:</p><pre class="programlisting">
query
    .where(doc.title.like(<strong class="hl-string"><em style="color:red">"*"</em></strong>))
    .filter(filter)
    .fetch();
</pre><p>A shortcut for distinct filtering is provided via the distinct(Path) method:
    </p><pre class="programlisting">
query
    .where(doc.title.like(<strong class="hl-string"><em style="color:red">"*"</em></strong>))
    .distinct(doc.title)
    .fetch();
</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hibernate_search_integration"></a>2.6.&nbsp;Querying Hibernate Search</h2></div></div></div><p>This chapter describes the querying functionality of
    the Hibernate Search module.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1717"></a>2.6.1.&nbsp;Creating the Querydsl query types</h3></div></div></div><p>
      See <a class="link" href="#jpa_integration" title="2.1.&nbsp;Querying JPA">Querying JPA/Hibernate sources</a>
      for instructions on how to create query types.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1725"></a>2.6.2.&nbsp;Querying</h3></div></div></div><p>Querying with Querydsl Hibernate Search is as simple as this:
    </p><pre class="programlisting">
QUser user = QUser.user;
SearchQuery&lt;User&gt; query = <strong class="hl-keyword">new</strong> SearchQuery&lt;User&gt;(session, user);
List&lt;User&gt; list = query
    .where(user.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>))
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1732"></a>2.6.3.&nbsp;General usage</h3></div></div></div><p>
      For general usage instructions see
      <a class="link" href="#lucene_integration" title="2.5.&nbsp;Querying Lucene">Querying Lucene sources</a>
      .
    </p><p>
      In the query serialization the only difference to the Querydsl Lucene module is that
      paths are treated differently.
      For <code class="code">org.hibernate.search.annotations.Field</code>
      annotated properties the
      name attribute is used with the property name as fallback for the field name.
    </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mongodb_integration"></a>2.7.&nbsp;Querying Mongodb</h2></div></div></div><p>This chapter describes the querying functionality of the Mongodb module.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1750"></a>2.7.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-apt<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-mongodb<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>
      And now, configure the Maven APT plugin which generates the query types
      used by Querydsl:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
      ...
      <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.mysema.maven<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>apt-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.1.3<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>process<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;outputDirectory&gt;</strong>target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/outputDirectory&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;processor&gt;</strong>com.querydsl.apt.morphia.MorphiaAnnotationProcessor<strong class="hl-tag" style="color: #000096">&lt;/processor&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>
      The MorphiaAnnotationProcessor finds domain types annotated with the
      <code class="code">com.google.code.morphia.annotations.Entity</code>
      annotation and generates Querydsl query types for them.
    </p><p>
      Run clean install and you will get your Query types generated into
      target/generated-sources/java.
    </p><p>
      If you use Eclipse, run mvn eclipse:eclipse to update your Eclipse project to
      include target/generated-sources/java as a source folder.
    </p><p>
      Now you are able to construct Mongodb queries and instances of the
      query domain model.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1772"></a>2.7.2.&nbsp;Querying</h3></div></div></div><p>Querying with Querydsl Mongodb with Morphia is as simple as this:
    </p><pre class="programlisting">
Morphia morphia;
Datastore datastore;
<em class="hl-comment" style="color: silver">// ...</em>
QUser user = <strong class="hl-keyword">new</strong> QUser(<strong class="hl-string"><em style="color:red">"user"</em></strong>);
MorphiaQuery&lt;User&gt; query = <strong class="hl-keyword">new</strong> MorphiaQuery&lt;User&gt;(morphia, datastore, user);
List&lt;User&gt; list = query
    .where(user.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>))
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1779"></a>2.7.3.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the MongodbQuery class like this</p><p>
      <span class="emphasis"><em>where:</em></span>
      Add the query filters, either in varargs form separated via commas or
      cascaded via the and-operator. Supported operations are operations performed on PStrings except
      <span class="emphasis"><em>
        matches
      </em></span>
      ,
      <span class="emphasis"><em>indexOf</em></span>
      ,
      <span class="emphasis"><em>charAt</em></span>
      . Currently
      <span class="emphasis"><em>in</em></span>
      is
      not supported, but will be in the future.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1811"></a>2.7.4.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
query
    .where(doc.title.like(<strong class="hl-string"><em style="color:red">"*"</em></strong>))
    .orderBy(doc.title.asc(), doc.year.desc())
    .fetch();
</pre><p>The results are sorted ascending based on title and year.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1820"></a>2.7.5.&nbsp;Limit</h3></div></div></div><p>The syntax for declaring a limit is </p><pre class="programlisting">
query
    .where(doc.title.like(<strong class="hl-string"><em style="color:red">"*"</em></strong>))
    .limit(<span class="hl-number">10</span>)
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1827"></a>2.7.6.&nbsp;Offset</h3></div></div></div><p>The syntax for declaring an offset is </p><pre class="programlisting">
query
    .where(doc.title.like(<strong class="hl-string"><em style="color:red">"*"</em></strong>))
    .offset(<span class="hl-number">3</span>)
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1834"></a>2.7.7.&nbsp;Geospatial queries</h3></div></div></div><p>Support for geospatial queries is available for Double typed arrays (Double[])
      via the near-method:
    </p><pre class="programlisting">
query
    .where(geoEntity.location.near(<span class="hl-number">50.0</span>, <span class="hl-number">50.0</span>))
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1841"></a>2.7.8.&nbsp;Select only relevant fields</h3></div></div></div><p>To select only relevant fields you can use the overloaded projection methods
      fetch, iterate, fetchOne and fetchFirst methods like this
    </p><pre class="programlisting">
query
    .where(doc.title.like(<strong class="hl-string"><em style="color:red">"*"</em></strong>))
    .fetch(doc.title, doc.path);
</pre><p>This query will load only the title and path fields of the documents.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections_integration"></a>2.8.&nbsp;Querying Collections</h2></div></div></div><p>The querydsl-collections module can be used with generated query types and
    without.
    The first section describes the usage without generated query types:
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1855"></a>2.8.1.&nbsp;Usage without generated query types</h3></div></div></div><p>
      To use querydsl-collections without generated query types you need to
      use the
      Querydsl alias feature. Here are some examples.
    </p><p>
      To get started, add the following static imports:
    </p><pre class="programlisting">
<em class="hl-comment" style="color: silver">// needed for access of the Querydsl Collections API</em>
<strong class="hl-keyword">import</strong> <strong class="hl-keyword">static</strong> com.querydsl.collections.CollQueryFactory.*;
<em class="hl-comment" style="color: silver">// needed, if you use the $-invocations</em>
<strong class="hl-keyword">import</strong> <strong class="hl-keyword">static</strong> com.querydsl.core.alias.Alias.*;
</pre><p>
      And now create an alias instance for the Cat class. Alias instances can only be
      created for non-final classes with an empty constructor. Make sure your class has one.
    </p><p>
      The alias instance of type Cat and its getter invocations are
      transformed into paths by wrapping them into dollar method invocations.
      The call
      <code class="code">c.getKittens()</code>
      for example is internally
      transformed into the property path <code class="code">c.kittens</code> inside the
      dollar method.
    </p><pre class="programlisting">
Cat c = alias(Cat.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"cat"</em></strong>);
<strong class="hl-keyword">for</strong> (String name : select($(c.getName())).from($(c),cats)
  .where($(c.getKittens()).size().gt(<span class="hl-number">0</span>))
  .fetch()) {
    System.out.println(name);
}
</pre><p>
      The following example is a variation of the previous, where the access
      to the
      list size happens inside the dollar-method invocation.
    </p><pre class="programlisting">
Cat c = alias(Cat.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"cat"</em></strong>);
<strong class="hl-keyword">for</strong> (String name : select($(c.getName())).from($(c),cats)
  .where($(c.getKittens().size()).gt(<span class="hl-number">0</span>))
  .fetch()) {
    System.out.println(name);
}
</pre><p>
      All non-primitive and non-final typed properties of aliases are aliases
      themselves. So you may cascade method calls until you hit a
      primitive or non-final type (e.g. java.lang.String) in the dollar-method scope.
    </p><p>
      e.g.
    </p><pre class="programlisting">
$(c.getMate().getName())
</pre><p>
      is transformed into
      <span class="emphasis"><em>c.mate.name</em></span>
      internally, but
    </p><pre class="programlisting">
$(c.getMate().getName().toLowerCase())
</pre><p>
      is not transformed properly, since the toLowerCase() invocation is not tracked.
    </p><p>
      Note also that you may only invoke getters, size(), contains(Object) and
      get(int) on alias types. All other invocations throw exceptions.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1897"></a>2.8.2.&nbsp;Usage with generated query types</h3></div></div></div><p>
      The example above can be expressed like this with generated expression types
    </p><pre class="programlisting">
QCat cat = <strong class="hl-keyword">new</strong> QCat(<strong class="hl-string"><em style="color:red">"cat"</em></strong>);
<strong class="hl-keyword">for</strong> (String name : select(cat.name).from(cat,cats)
  .where(cat.kittens.size().gt(<span class="hl-number">0</span>))
  .fetch()) {
    System.out.println(name);
}
</pre><p>When you use generated query types, you instantiate expressions instead of alias
      instances
      and use the property paths directly without any dollar-method wrapping.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1906"></a>2.8.3.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-apt<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-collections<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>
      If you are not using JPA or JDO you can generate expression types for your
      domain types by
      annotating them with the
      <code class="code">com.querydsl.core.annotations.QueryEntity</code>
      annotation and adding the
      following plugin configuration into your Maven configuration (pom.xml):
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.mysema.maven<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>apt-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.1.3<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>process<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;outputDirectory&gt;</strong>target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/outputDirectory&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;processor&gt;</strong>com.querydsl.apt.QuerydslAnnotationProcessor<strong class="hl-tag" style="color: #000096">&lt;/processor&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
    ...
  <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1920"></a>2.8.4.&nbsp;Ant integration</h3></div></div></div><p>Place the jar files from the full-deps bundle on your classpath and use the
      following tasks for Querydsl code generation:
    </p><pre class="programlisting">
    <em class="hl-comment" style="color: silver">&lt;!-- APT based code generation --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;javac</strong> <span class="hl-attribute" style="color: #F5844C">srcdir</span>=<span class="hl-value" style="color: #993300">"${src}"</span> <span class="hl-attribute" style="color: #F5844C">classpathref</span>=<span class="hl-value" style="color: #993300">"cp"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"-proc:only"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"-processor"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"com.querydsl.apt.QuerydslAnnotationProcessor"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"-s"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;compilerarg</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${generated}"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/javac&gt;</strong>

    <em class="hl-comment" style="color: silver">&lt;!-- compilation --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;javac</strong> <span class="hl-attribute" style="color: #F5844C">classpathref</span>=<span class="hl-value" style="color: #993300">"cp"</span> <span class="hl-attribute" style="color: #F5844C">destdir</span>=<span class="hl-value" style="color: #993300">"${build}"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;src</strong> <span class="hl-attribute" style="color: #F5844C">path</span>=<span class="hl-value" style="color: #993300">"${src}"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;src</strong> <span class="hl-attribute" style="color: #F5844C">path</span>=<span class="hl-value" style="color: #993300">"${generated}"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/javac&gt;</strong>
</pre><p>
      Replace
      <span class="emphasis"><em>src</em></span>
      with your main source folder,
      <span class="emphasis"><em>generated</em></span>
      with your folder for generated sources and
      <span class="emphasis"><em>build</em></span>
      with your target folder.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1938"></a>2.8.5.&nbsp;Hamcrest matchers</h3></div></div></div><p>Querydsl Collections provides Hamcrest matchers. With these imports</p><pre class="programlisting">
<strong class="hl-keyword">import</strong> <strong class="hl-keyword">static</strong> org.hamcrest.core.IsEqual.equalTo;
<strong class="hl-keyword">import</strong> <strong class="hl-keyword">static</strong> com.querydsl.collections.PathMatcher.hasValue;
<strong class="hl-keyword">import</strong> <strong class="hl-keyword">static</strong> org.junit.Assert.assertEquals;
<strong class="hl-keyword">import</strong> <strong class="hl-keyword">static</strong> org.junit.Assert.assertThat;
</pre><p>they can be used like this:</p><pre class="programlisting">
Car car = <strong class="hl-keyword">new</strong> Car();
car.setHorsePower(<span class="hl-number">123</span>);

assertThat(car, hasValue($.horsePower));
assertThat(car, hasValue($.horsePower, equalTo(<span class="hl-number">123</span>)));
</pre><p>
      The Hamcrest matchers have been contributed by
      <a class="ulink" href="https://github.com/jeroenvs" target="_top">Jeroen van Schagen</a>
      .
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1954"></a>2.8.6.&nbsp;Usage with the Eclipse Compiler for Java</h3></div></div></div><p>If Querydsl Collections is used with a JRE where the system compiler is not available,
    CollQuery instances can also be configured to use the Eclipse Compiler for Java (ECJ) instead:</p><pre class="programlisting">
DefaultEvaluatorFactory evaluatorFactory = <strong class="hl-keyword">new</strong> DefaultEvaluatorFactory(
    CollQueryTemplates.DEFAULT,
    <strong class="hl-keyword">new</strong> ECJEvaluatorFactory(getClass().getClassLoader()));
QueryEngine queryEngine = <strong class="hl-keyword">new</strong> DefaultQueryEngine(evaluatorFactory);
CollQuery query = <strong class="hl-keyword">new</strong> CollQuery(queryEngine);
</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scala"></a>2.9.&nbsp;Querying in Scala</h2></div></div></div><p>Generic support for Querydsl usage in Scala is available via querydsl-scala
    module. To add it to your Maven build, use the following snippet:
  </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-scala<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1968"></a>2.9.1.&nbsp;DSL expressions for Scala</h3></div></div></div><p>Querydsl for Scala provides an alternative DSL for expression construction. The
      Scala DSL utilizes language features such as operator overloading,
      function pointers and implicit imports for enhanced readability and conciseness.
    </p><p>Here is an overview of the main alternatives :</p><pre class="programlisting">
//Standard              Alternative

expr isNotNull          expr is not(null)
expr isNull             expr is null
expr eq "Ben"           expr === "Ben"
expr ne "Ben"           expr !== "Ben"
expr append "X"         expr + "X"
expr isEmpty            expr is empty
expr isNotEmpty         expr not empty

// boolean
left and right          left &amp;&amp; right
left or right           left || right
expr not                !expr

// comparison
expr lt 5               expr &lt; 5
expr loe 5              expr &lt;= 5
expr gt 5               expr &gt; 5
expr goe 5              expr &gt;= 5
expr notBetween(2,6)    expr not between (2,6)
expr negate             -expr

// numeric
expr add 3              expr + 3
expr subtract 3         expr - 3
expr divide 3           expr / 3
expr multiply 3         expr * 3
expr mod 5              expr % 5

// collection
list.get(0)             list(0)
map.get("X")            map("X")
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1978"></a>2.9.2.&nbsp;Querying with SQL</h3></div></div></div><p>
      Like with Querydsl SQL for Java you need to generate Query types to be able to construct
      your queries. The following code examples show how this is done:
    </p><p>Generation without Bean types :</p><pre class="programlisting">
val directory = <strong class="hl-keyword">new</strong> java.io.File(<strong class="hl-string"><em style="color:red">"target/jdbcgen1"</em></strong>)
val namingStrategy = <strong class="hl-keyword">new</strong> DefaultNamingStrategy()
val exporter = <strong class="hl-keyword">new</strong> MetaDataExporter()
exporter.setNamePrefix(<strong class="hl-string"><em style="color:red">"Q"</em></strong>)
exporter.setPackageName(<strong class="hl-string"><em style="color:red">"com.querydsl"</em></strong>)
exporter.setSchemaPattern(<strong class="hl-string"><em style="color:red">"PUBLIC"</em></strong>)
exporter.setTargetFolder(directory)
exporter.setSerializerClass(classOf[ScalaMetaDataSerializer])
exporter.setCreateScalaSources(true)
exporter.setTypeMappings(ScalaTypeMappings.create)
exporter.export(connection.getMetaData)
</pre><p>Generation with Bean types :</p><pre class="programlisting">
val directory = <strong class="hl-keyword">new</strong> java.io.File(<strong class="hl-string"><em style="color:red">"target/jdbcgen2"</em></strong>)
val namingStrategy = <strong class="hl-keyword">new</strong> DefaultNamingStrategy()
val exporter = <strong class="hl-keyword">new</strong> MetaDataExporter()
exporter.setNamePrefix(<strong class="hl-string"><em style="color:red">"Q"</em></strong>)
exporter.setPackageName(<strong class="hl-string"><em style="color:red">"com.querydsl"</em></strong>)
exporter.setSchemaPattern(<strong class="hl-string"><em style="color:red">"PUBLIC"</em></strong>)
exporter.setTargetFolder(directory)
exporter.setSerializerClass(classOf[ScalaMetaDataSerializer])
exporter.setBeanSerializerClass(classOf[ScalaBeanSerializer])
exporter.setCreateScalaSources(true)
exporter.setTypeMappings(ScalaTypeMappings.create)
exporter.export(connection.getMetaData)
</pre><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1991"></a>2.9.2.1.&nbsp;Code generation</h4></div></div></div><p>Scala sources for SQL metatypes and projections can be generated with
        querydsl-maven-plugin. Here is an example configuration
      </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
      ...
      <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcDriver&gt;</strong>com.mysql.jdbc.Driver<strong class="hl-tag" style="color: #000096">&lt;/jdbcDriver&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcUrl&gt;</strong>jdbc:mysql://localhost:3306/test<strong class="hl-tag" style="color: #000096">&lt;/jdbcUrl&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcUser&gt;</strong>matko<strong class="hl-tag" style="color: #000096">&lt;/jdbcUser&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcPassword&gt;</strong>matko<strong class="hl-tag" style="color: #000096">&lt;/jdbcPassword&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;packageName&gt;</strong>com.example.schema<strong class="hl-tag" style="color: #000096">&lt;/packageName&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;targetFolder&gt;</strong>${project.basedir}/src/main/scala<strong class="hl-tag" style="color: #000096">&lt;/targetFolder&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;exportBeans&gt;</strong>true<strong class="hl-tag" style="color: #000096">&lt;/exportBeans&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;createScalaSources&gt;</strong>true<strong class="hl-tag" style="color: #000096">&lt;/createScalaSources&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>mysql<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>mysql-connector-java<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>5.1.16<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-scala<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.scala-lang<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>scala-library<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${scala.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
      ...
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>The maven goal to execute is querydsl:export.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2000"></a>2.9.3.&nbsp;Querying with other backends</h3></div></div></div><p>When querying with other backends the Expression model has to be created
      manually or alternatively the alias functionality can be used.
    </p><p>Here is a minimal example with JPA :</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<strong class="hl-keyword">class</strong> User {
  <em><span class="hl-annotation" style="color: gray">@BeanProperty</span></em>
  <em><span class="hl-annotation" style="color: gray">@Id</span></em>
  var id: Integer = _;
  <em><span class="hl-annotation" style="color: gray">@BeanProperty</span></em>
  var userName: String = _;
  <em><span class="hl-annotation" style="color: gray">@BeanProperty</span></em>
  <em><span class="hl-annotation" style="color: gray">@ManyToOne</span></em>
  var department: Department = _;
}

<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<strong class="hl-keyword">class</strong> Department {
  <em><span class="hl-annotation" style="color: gray">@BeanProperty</span></em>
  <em><span class="hl-annotation" style="color: gray">@Id</span></em>
  var id: Integer = _;
  <em><span class="hl-annotation" style="color: gray">@BeanProperty</span></em>
  var name: String = _;
}
</pre><p>And here are some query examples</p><p>List</p><pre class="programlisting">
val person = Person as <strong class="hl-string"><em style="color:red">"person"</em></strong>

selectFrom(person).where(person.firstName like <strong class="hl-string"><em style="color:red">"Rob%"</em></strong>).fetch()
</pre><p>Unique result</p><pre class="programlisting">
selectFrom(person).where(person.firstName like <strong class="hl-string"><em style="color:red">"Rob%"</em></strong>).fetchOne()
</pre><p>Long where</p><pre class="programlisting">
selectFrom(person)
  .where(person.firstName like <strong class="hl-string"><em style="color:red">"Rob%"</em></strong>, person.lastName like <strong class="hl-string"><em style="color:red">"An%"</em></strong>)
  .fetch()
</pre><p>Order</p><pre class="programlisting">
selectFrom(person).orderBy(person.firstName asc).fetch()
</pre><p>Not null</p><pre class="programlisting">
selectFrom(person)
  .where(person.firstName isEmpty, person.lastName isNotNull)
  .fetch()
</pre><p>The factory method for query creation is</p><pre class="programlisting">
def query() = <strong class="hl-keyword">new</strong> JPAQuery(entityManager)
</pre><p>In addition to queries you need variables which can be created like this</p><pre class="programlisting">
val person = Person as <strong class="hl-string"><em style="color:red">"person"</em></strong>
</pre><p>Note: the Scala support is not yet available if you use Hibernate with an XML based configuration. HibernateDomainExporter currently only outputs Java source files.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="general"></a>3.&nbsp;General usage</h1></div></div></div><p>
    The General usage section covers aspects that are not covered in the tutorial section of the reference documentation.
    It follows a use case oriented structure.
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="creating_queries"></a>3.1.&nbsp;Creating queries</h2></div></div></div><p>Query construction in Querydsl involves calling query methods with expression arguments. Since
  query methods are mostly module specific and have already been presented in the tutorial section,
  this part will focus on expressions.</p><p>Expressions are normally constructed by accessing fields and calling methods on the generated
  expression types of your domain module. For cases where code generation is not applicable generic ways
  to construct expressions can be used instead.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2053"></a>3.1.1.&nbsp;Complex predicates</h3></div></div></div><p>
      To construct complex boolean expressions, use the <code class="code">com.querydsl.core.BooleanBuilder</code> class. It
      implements Predicate and can be used in cascaded form:
    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> List&lt;Customer&gt; getCustomer(String... names) {
    QCustomer customer = QCustomer.customer;
    JPAQuery&lt;Customer&gt; query = queryFactory.selectFrom(customer);
    BooleanBuilder builder = <strong class="hl-keyword">new</strong> BooleanBuilder();
    <strong class="hl-keyword">for</strong> (String name : names) {
        builder.or(customer.name.eq(name));
    }
    query.where(builder); <em class="hl-comment" style="color: silver">// customer.name eq name1 OR customer.name eq name2 OR ...</em>
    <strong class="hl-keyword">return</strong> query.fetch();
}
</pre><p><code class="code">BooleanBuilder</code> is mutable and represents initially null and after each <code class="code">and</code>
    or <code class="code">or</code> call the result of the operation.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2073"></a>3.1.2.&nbsp;Dynamic expressions</h3></div></div></div><p>
      The <code class="code">com.querydsl.core.types.dsl.Expressions</code>
      class is a static factory class for dynamic expression construction.
      The factory methods are named by the returned type and are mostly self-documenting.
    </p><p>
    In general the <code class="code">Expressions</code> class should be used only in cases where fluent DSL forms
    can't be used, such as dynamic paths, custom syntax or custom operations.
    </p><p>The following expression </p><pre class="programlisting">
QPerson person = QPerson.person;
person.firstName.startsWith(<strong class="hl-string"><em style="color:red">"P"</em></strong>);
</pre><p>could be constructed like this if Q-types wouldn't be available </p><pre class="programlisting">
Path&lt;Person&gt; person = Expressions.path(Person.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"person"</em></strong>);
Path&lt;String&gt; personFirstName = Expressions.path(String.<strong class="hl-keyword">class</strong>, person, <strong class="hl-string"><em style="color:red">"firstName"</em></strong>);
Constant&lt;String&gt; constant = Expressions.constant(<strong class="hl-string"><em style="color:red">"P"</em></strong>);
Expressions.predicate(Ops.STARTS_WITH, personFirstName, constant);
</pre><p>Path instances represent variables and properties, Constants are constants,
      Operations are operations and TemplateExpression instances can be used to express
      expressions as String templates.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2096"></a>3.1.3.&nbsp;Dynamic paths</h3></div></div></div><p>In addition to the <code class="code">Expressions</code> based expression creation Querydsl provides
    also a more fluent API for dynamic path creation.</p><p>
      For dynamic path generation the <code class="code">com.querydsl.core.types.dsl.PathBuilder</code> class can be used. It extends
      <code class="code">EntityPathBase</code> and can be used as an alternative to class generation and alias-usage
      for path generation.
    </p><p>
    Compared to the Expressions API PathBuilder doesn't provide direct support for unknown operations
    or custom syntax, but the syntax is closer to the normal DSL.
    </p><p>String property:</p><pre class="programlisting">
PathBuilder&lt;User&gt; entityPath = <strong class="hl-keyword">new</strong>
PathBuilder&lt;User&gt;(User.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"entity"</em></strong>);
<em class="hl-comment" style="color: silver">// fully generic access</em>
entityPath.get(<strong class="hl-string"><em style="color:red">"userName"</em></strong>);
<em class="hl-comment" style="color: silver">// .. or with supplied type</em>
entityPath.get(<strong class="hl-string"><em style="color:red">"userName"</em></strong>, String.<strong class="hl-keyword">class</strong>);
<em class="hl-comment" style="color: silver">// .. and correct signature</em>
entityPath.getString(<strong class="hl-string"><em style="color:red">"userName"</em></strong>).lower();
</pre><p>List property with component type: </p><pre class="programlisting">
entityPath.getList(<strong class="hl-string"><em style="color:red">"list"</em></strong>, String.<strong class="hl-keyword">class</strong>).get(<span class="hl-number">0</span>);
</pre><p>Using a component expression type:</p><pre class="programlisting">
entityPath.getList(<strong class="hl-string"><em style="color:red">"list"</em></strong>, String.<strong class="hl-keyword">class</strong>, StringPath.<strong class="hl-keyword">class</strong>).get(<span class="hl-number">0</span>).lower();
</pre><p>Map property with key and value type: </p><pre class="programlisting">
entityPath.getMap(<strong class="hl-string"><em style="color:red">"map"</em></strong>, String.<strong class="hl-keyword">class</strong>, String.<strong class="hl-keyword">class</strong>).get(<strong class="hl-string"><em style="color:red">"key"</em></strong>);
</pre><p>Using a component expression type:</p><pre class="programlisting">
entityPath.getMap(<strong class="hl-string"><em style="color:red">"map"</em></strong>, String.<strong class="hl-keyword">class</strong>, String.<strong class="hl-keyword">class</strong>, StringPath.<strong class="hl-keyword">class</strong>).get(<strong class="hl-string"><em style="color:red">"key"</em></strong>).lower();
</pre><p>For PathBuilder validation a PathBuilderValidator can be used. It can be injected in the constructor
    and will be used transitively for the new PathBuilder</p><pre class="programlisting">
PathBuilder&lt;Customer&gt; customer = <strong class="hl-keyword">new</strong> PathBuilder&lt;Customer&gt;(Customer.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"customer"</em></strong>, validator);
</pre><p>PathBuilderValidator.FIELDS will verify field existence, PathBuilderValidator.PROPERTIES validates
      Bean properties and JPAPathBuilderValidator validates using a JPA metamodel.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2140"></a>3.1.4.&nbsp;Case expressions</h3></div></div></div><p>To construct case-when-then-else expressions use the
      <code class="code">CaseBuilder</code> class like this:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
Expression&lt;String&gt; cases = <strong class="hl-keyword">new</strong> CaseBuilder()
    .when(customer.annualSpending.gt(<span class="hl-number">10000</span>)).then(<strong class="hl-string"><em style="color:red">"Premier"</em></strong>)
    .when(customer.annualSpending.gt(<span class="hl-number">5000</span>)).then(<strong class="hl-string"><em style="color:red">"Gold"</em></strong>)
    .when(customer.annualSpending.gt(<span class="hl-number">2000</span>)).then(<strong class="hl-string"><em style="color:red">"Silver"</em></strong>)
    .otherwise(<strong class="hl-string"><em style="color:red">"Bronze"</em></strong>);
<em class="hl-comment" style="color: silver">// The cases expression can now be used in a projection or condition</em>
</pre><p>For case expressions with equals-operations use the following simpler form instead:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
Expression&lt;String&gt; cases = customer.annualSpending
    .when(<span class="hl-number">10000</span>).then(<strong class="hl-string"><em style="color:red">"Premier"</em></strong>)
    .when(<span class="hl-number">5000</span>).then(<strong class="hl-string"><em style="color:red">"Gold"</em></strong>)
    .when(<span class="hl-number">2000</span>).then(<strong class="hl-string"><em style="color:red">"Silver"</em></strong>)
    .otherwise(<strong class="hl-string"><em style="color:red">"Bronze"</em></strong>);
<em class="hl-comment" style="color: silver">// The cases expression can now be used in a projection or condition</em>
</pre><p>Case expressions are not yet supported in JDOQL.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2156"></a>3.1.5.&nbsp;Casting expressions</h3></div></div></div><p>
      To avoid a generic signature in expression types the type hierarchies are
      flattened. The result is that all generated query types are direct subclasses of
      <code class="code">com.querydsl.core.types.dsl.EntityPathBase</code>
      or
      <code class="code">com.querydsl.core.types.dsl.BeanPath</code>
      and cannot be directly cast to their logical supertypes.
    </p><p>
      Instead of a direct Java cast, the supertype reference is accessible via the
      <code class="code">_super</code> field. A _super-field is available in all generated query types with a single
      supertype:
    </p><pre class="programlisting">
<em class="hl-comment" style="color: silver">// from Account</em>
QAccount <strong class="hl-keyword">extends</strong> EntityPathBase&lt;Account&gt; {
    <em class="hl-comment" style="color: silver">// ...</em>
}

<em class="hl-comment" style="color: silver">// from BankAccount extends Account</em>
QBankAccount <strong class="hl-keyword">extends</strong> EntityPathBase&lt;BankAccount&gt; {

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">final</strong> QAccount _super = <strong class="hl-keyword">new</strong> QAccount(<strong class="hl-keyword">this</strong>);

    <em class="hl-comment" style="color: silver">// ...</em>
}
</pre><p>To cast from a supertype to a subtype you can use the
      as-method of the
      EntityPathBase class:
    </p><pre class="programlisting">
QAccount account = <strong class="hl-keyword">new</strong> QAccount(<strong class="hl-string"><em style="color:red">"account"</em></strong>);
QBankAccount bankAccount = account.as(QBankAccount.<strong class="hl-keyword">class</strong>);
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2178"></a>3.1.6.&nbsp;Select literals</h3></div></div></div><p>Literals can be selected by referring to them via Constant expressions. Here is a simple example </p><pre class="programlisting">
query.select(Expressions.constant(<span class="hl-number">1</span>),
             Expressions.constant(<strong class="hl-string"><em style="color:red">"abc"</em></strong>));
</pre><p>Constant expressions are often used in subqueries.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="result_handling"></a>3.2.&nbsp;Result handling</h2></div></div></div><p>Querydsl provides two ways to customize results, FactoryExpressions for row based transformation
  and ResultTransformer for aggregation.</p><p>The <code class="code">com.querydsl.core.types.FactoryExpression</code> interface is used for Bean creation,
  constructor invocation and for the creation of more complex objects. The functionality of the
  FactoryExpression implementations of Querydsl can be accessed via the
  <code class="code">com.querydsl.core.types.Projections</code> class.</p><p>For the <code class="code">com.querydsl.core.ResultTransformer</code> interface <code class="code">GroupBy</code> is the
  main implementation.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2208"></a>3.2.1.&nbsp;Returning multiple columns</h3></div></div></div><p>Since Querydsl 3.0 the default type for multi-column results is <code class="code">com.querydsl.core.Tuple</code>.
    Tuple provides provides a typesafe Map like interface to access column data from a Tuple row object.</p><pre class="programlisting">
List&lt;Tuple&gt; result = query.select(employee.firstName, employee.lastName)
                          .from(employee).fetch();
<strong class="hl-keyword">for</strong> (Tuple row : result) {
     System.out.println(<strong class="hl-string"><em style="color:red">"firstName "</em></strong> + row.get(employee.firstName));
     System.out.println(<strong class="hl-string"><em style="color:red">"lastName "</em></strong> + row.get(employee.lastName));
}}
</pre><p>This example could also have been written via the QTuple expression class like this</p><pre class="programlisting">
List&lt;Tuple&gt; result = query.select(<strong class="hl-keyword">new</strong> QTuple(employee.firstName, employee.lastName))
                          .from(employee).fetch();
<strong class="hl-keyword">for</strong> (Tuple row : result) {
     System.out.println(<strong class="hl-string"><em style="color:red">"firstName "</em></strong> + row.get(employee.firstName));
     System.out.println(<strong class="hl-string"><em style="color:red">"lastName "</em></strong> + row.get(employee.lastName));
}}
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2222"></a>3.2.2.&nbsp;Bean population</h3></div></div></div><p>In cases where Beans need to be populated based on the results of the query, Bean projections
    can be used like this</p><pre class="programlisting">
List&lt;UserDTO&gt; dtos = query.select(
    Projections.bean(UserDTO.<strong class="hl-keyword">class</strong>, user.firstName, user.lastName)).fetch();
</pre><p>When fields should be directly used instead of setters the following variant can be
   used instead</p><pre class="programlisting">
List&lt;UserDTO&gt; dtos = query.select(
    Projections.fields(UserDTO.<strong class="hl-keyword">class</strong>, user.firstName, user.lastName)).fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2233"></a>3.2.3.&nbsp;Constructor usage</h3></div></div></div><p>Constructor based row transformation can be used like this</p><pre class="programlisting">
List&lt;UserDTO&gt; dtos = query.select(
    Projections.constructor(UserDTO.<strong class="hl-keyword">class</strong>, user.firstName, user.lastName)).fetch();
</pre><p>As an alternative to the generic Constructor expression usage constructors
    can also be annotated with the <code class="code">QueryProjection</code> annotation:
    </p><pre class="programlisting">
<strong class="hl-keyword">class</strong> CustomerDTO {

  <em><span class="hl-annotation" style="color: gray">@QueryProjection</span></em>
  <strong class="hl-keyword">public</strong> CustomerDTO(<strong class="hl-keyword">long</strong> id, String name) {
     ...
  }

}
</pre><p>And then you can use it like this in the query</p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
JPQLQuery query = <strong class="hl-keyword">new</strong> HibernateQuery(session);
List&lt;CustomerDTO&gt; dtos = query.select(<strong class="hl-keyword">new</strong> QCustomerDTO(customer.id, customer.name))
                              .from(customer).fetch();
</pre><p>While the example is Hibernate specific, this feature is
      available in all modules.
    </p><p>If the type with the QueryProjection annotation is not an annotated entity
      type, you can use the constructor projection like in the example, but if the
      annotated type would be an entity type, then the constructor projection would need to be
      created via a call to the static create method of the query type:
    </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<strong class="hl-keyword">class</strong> Customer {

  <em><span class="hl-annotation" style="color: gray">@QueryProjection</span></em>
  <strong class="hl-keyword">public</strong> Customer(<strong class="hl-keyword">long</strong> id, String name) {
     ...
  }

}
</pre><pre class="programlisting">
QCustomer customer = QCustomer.customer;
JPQLQuery query = <strong class="hl-keyword">new</strong> HibernateQuery(session);
List&lt;Customer&gt; dtos = query.select(QCustomer.create(customer.id, customer.name))
                           .from(customer).fetch();
</pre><p>Alternatively, if code generation is not an option, you can
      create a constructor projection like this:
    </p><pre class="programlisting">
List&lt;Customer&gt; dtos = query
    .select(Projections.constructor(Customer.<strong class="hl-keyword">class</strong>, customer.id, customer.name))
    .from(customer).fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2263"></a>3.2.4.&nbsp;Result aggregation</h3></div></div></div><p>
      The
      <code class="code">com.querydsl.core.group.GroupBy</code>
      class provides aggregation functionality which can be used to aggregate query results
      in memory. Below are some usage examples.
    </p><p>
      Aggregating parent child relations
    </p><pre class="programlisting">
<strong class="hl-keyword">import</strong> <strong class="hl-keyword">static</strong> com.querydsl.core.group.GroupBy.*;

Map&lt;Integer, List&lt;Comment&gt;&gt; results = query.from(post, comment)
    .where(comment.post.id.eq(post.id))
    .transform(groupBy(post.id).as(list(comment)));
</pre><p>This will return a map of post ids to related comments.</p><p>Multiple result columns</p><pre class="programlisting">
Map&lt;Integer, Group&gt; results = query.from(post, comment)
    .where(comment.post.id.eq(post.id))
    .transform(groupBy(post.id).as(post.name, set(comment.id)));
</pre><p>This will return a map of post ids to Group instances with
      access to post name
      and comment ids.
    </p><p>Group is the GroupBy equivalent to the Tuple interface.</p><p>
      More examples can be found
      <a class="ulink" href="https://github.com/querydsl/querydsl/blob/master/querydsl-collections/src/test/java/com/querydsl/collections/GroupByTest.java" target="_top">here</a>
      .
    </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="codegen"></a>3.3.&nbsp;Code generation</h2></div></div></div><p>The Java 6 APT annotation processing functionality is used in Querydsl for code
    generation in the JPA, JDO and Mongodb modules. This section describes various configuration
    options for the code generation and an alternative to APT usage.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2295"></a>3.3.1.&nbsp;Path initialization</h3></div></div></div><p>
      By default Querydsl initializes only reference properties of the first two levels. In cases where
      longer initialization paths are required, these have to be annotated in the domain
      types via
       <code class="code">com.querydsl.core.annotations.QueryInit</code>
      annotations. QueryInit is used on properties where deep initializations are
      needed. The following example demonstrates the usage.
    </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<strong class="hl-keyword">class</strong> Event {
    <em><span class="hl-annotation" style="color: gray">@QueryInit("customer.address")</span></em>
    Account account;
}

<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<strong class="hl-keyword">class</strong> Account {
    Customer customer;
}

<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<strong class="hl-keyword">class</strong> Customer {
    String name;
    Address address;
    <em class="hl-comment" style="color: silver">// ...</em>
}
</pre><p>
      This example enforces the initialization of the account.customer path, when an
      Event path is initialized as a root path / variable. The path initialization
      format supports wildcards as well, e.g. "customer.*" or just "*".
    </p><p>
      The automatic path initialization replaces the manual one, which
      required the entity fields to be non-final. The declarative format has the benefit
      to be applied to all top level instances of a Query type and to enable the usage
      of final entity fields.
    </p><p>
      Automatic path initialization is the preferred initialization strategy, but
      manual initialization can be activated via the Config annotation, which is
      described below.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2311"></a>3.3.2.&nbsp;Customization</h3></div></div></div><p>
      The serialization of Querydsl can be customized via Config annotations on
      packages and types. They customize the serialization of the annotated package or type.
    </p><p>
      The serialization options are
    </p><div class="table"><a name="d0e2318"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Config options</b></p><div class="table-contents"><table class="table" summary="Config options" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col align="left" class="Name"><col align="left" class="Descriptions"></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Name</th><th style="border-bottom: 1px solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">entityAccessors</td><td style="border-bottom: 1px solid ; " align="left">accessor methods for entity paths instead of public final fields (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">listAccessors</td><td style="border-bottom: 1px solid ; " align="left">listProperty(int index) style methods (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">mapAccessors</td><td style="border-bottom: 1px solid ; " align="left">mapProperty(Key key) style accessor methods (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">createDefaultVariable</td><td style="border-bottom: 1px solid ; " align="left">generate the default variable (default: true)</td></tr><tr><td style="border-right: 1px solid ; " align="left">defaultVariableName</td><td style="" align="left">name of the default variable</td></tr></tbody></table></div></div><br class="table-break"><p>Below are some examples.</p><p>Customization of Entity type serialization:</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Config(entityAccessors=true)</span></em>
<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> User {
    <em class="hl-comment" style="color: silver">//...</em>
}
</pre><p>Customization of package content:</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Config(listAccessors=true)</span></em>
<strong class="hl-keyword">package</strong> com.querydsl.core.domain.rel;

<strong class="hl-keyword">import</strong> com.querydsl.core.annotations.Config;
</pre><p>
      If you want to customize the serializer configuration globally,
      you can do this via the following APT options
    </p><div class="table"><a name="d0e2369"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;APT options</b></p><div class="table-contents"><table class="table" summary="APT options" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col align="left" class="Name"><col align="left" class="Descriptions"></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Name</th><th style="border-bottom: 1px solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.entityAccessors</td><td style="border-bottom: 1px solid ; " align="left">enable reference field accessors</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.listAccessors</td><td style="border-bottom: 1px solid ; " align="left">enable accessors for direct indexed list access</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.mapAccessors</td><td style="border-bottom: 1px solid ; " align="left">enable accessors for direct key based map access</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.prefix</td><td style="border-bottom: 1px solid ; " align="left">override the prefix for query types(default: Q)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.suffix</td><td style="border-bottom: 1px solid ; " align="left">set a suffix for query types</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.packageSuffix</td><td style="border-bottom: 1px solid ; " align="left">set a suffix for query type packages</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.createDefaultVariable</td><td style="border-bottom: 1px solid ; " align="left">set whether default variables are created</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.unknownAsEmbeddable</td><td style="border-bottom: 1px solid ; " align="left">set where unknown non-annotated classes should be treated as embeddable (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.includedPackages</td><td style="border-bottom: 1px solid ; " align="left">comma separated list of packages to be included into code generation (default: all)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.includedClasses</td><td style="border-bottom: 1px solid ; " align="left">comma separated list of class names to be included into code generation (default: all)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.excludedPackages</td><td style="border-bottom: 1px solid ; " align="left">comma separated list of packages to be excluded from code generation (default: none)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.excludedClasses</td><td style="border-bottom: 1px solid ; " align="left">comma separated list of class names to be excluded from code generation (default: none)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.useFields</td><td style="border-bottom: 1px solid ; " align="left">set whether fields are used as metadata source (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">querydsl.useGetters</td><td style="border-bottom: 1px solid ; " align="left">set whether accessors are used as metadata source (default: true)</td></tr><tr><td style="border-right: 1px solid ; " align="left">querydsl.generatedAnnotationClass</td><td style="" align="left">
              The fully qualified class name of the <span class="emphasis"><em>Single-Element Annotation</em></span> (with String element) to be added on the generated sources. Build in
              <span class="emphasis"><em>com.querydsl.core.annotations.Generated</em></span>has CLASS retention which can be used for byte code analysis tools like Jacoco.
              (default: <span class="emphasis"><em>javax.annotation.Generated</em></span> or<span class="emphasis"><em>javax.annotation.processing.Generated</em></span> depending on the java version). See also
              <a class="ulink" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7.3" target="_top">Single-Element Annotation</a>
            </td></tr></tbody></table></div></div><br class="table-break"><p>Using the Maven APT plugin this works for example like this:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.mysema.maven<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>apt-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.1.3<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>process<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;outputDirectory&gt;</strong>target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/outputDirectory&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;processor&gt;</strong>com.querydsl.apt.jpa.JPAAnnotationProcessor<strong class="hl-tag" style="color: #000096">&lt;/processor&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;options&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;querydsl.entityAccessors&gt;</strong>true<strong class="hl-tag" style="color: #000096">&lt;/querydsl.entityAccessors&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;querydsl.useFields&gt;</strong>false<strong class="hl-tag" style="color: #000096">&lt;/querydsl.useFields&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/options&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
    ...
  <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>
      Alternatively <code class="code">maven-compiler-plugin</code> can be configured
      to hook APT directly into compilation:
    </p><pre class="programlisting">
      <strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
          ...
          <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>maven-compiler-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;generatedSourcesDirectory&gt;</strong>target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/generatedSourcesDirectory&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;compilerArgs&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;arg&gt;</strong>-Aquerydsl.entityAccessors=true<strong class="hl-tag" style="color: #000096">&lt;/arg&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;arg&gt;</strong>-Aquerydsl.useFields=false<strong class="hl-tag" style="color: #000096">&lt;/arg&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;/compilerArgs&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-apt<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;classifier&gt;</strong>jpa<strong class="hl-tag" style="color: #000096">&lt;/classifier&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.hibernate.javax.persistence<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>hibernate-jpa-2.1-api<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.0.0.Final<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
          ...
        <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>
      Notice that you need to use a proper classifier when defining dependency
      to <code class="code">com.querydsl:querydsl-apt</code>. Those additional artifacts
      define the annotation processor to be used in
      <code class="code">META-INF/services/javax.annotation.processing.Processor</code>.
    </p><p>Available classifiers include:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="code">general</code></li><li class="listitem"><code class="code">hibernate</code></li><li class="listitem"><code class="code">jdo</code></li><li class="listitem"><code class="code">jpa</code></li></ul></div><p>
      With this configuration query objects can have their sources generated
      and compiled during compilation of the domain objects. This will also
      automatically add the generated sources directory to Maven project
      source roots.
    </p><p>
      The great advantage of this approach is that it can also handle
      annotated Groovy classes using <code class="code">groovy-eclipse</code> compiler:
    </p><pre class="programlisting">
      <strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
          ...
          <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>maven-compiler-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;compilerId&gt;</strong>groovy-eclipse-compiler<strong class="hl-tag" style="color: #000096">&lt;/compilerId&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;generatedSourcesDirectory&gt;</strong>target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/generatedSourcesDirectory&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;compilerArgs&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;arg&gt;</strong>-Aquerydsl.entityAccessors=true<strong class="hl-tag" style="color: #000096">&lt;/arg&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;arg&gt;</strong>-Aquerydsl.useFields=false<strong class="hl-tag" style="color: #000096">&lt;/arg&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;/compilerArgs&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.codehaus.groovy<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>groovy-eclipse-compiler<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>2.9.1-01<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.codehaus.groovy<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>groovy-eclipse-batch<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>2.3.7-01<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-apt<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;classifier&gt;</strong>jpa<strong class="hl-tag" style="color: #000096">&lt;/classifier&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.hibernate.javax.persistence<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>hibernate-jpa-2.1-api<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.0.0.Final<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
          ...
        <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="custom_types"></a>3.3.3.&nbsp;Custom type mappings</h3></div></div></div><p>
      Custom type mappings can be used on properties to override the derived Path
      type. This can be useful for example in cases where comparison and String operations should
      be blocked on certain String paths or Date / Time support for
      custom types needs to be added. Support for Date / Time types of the Joda time API
      and JDK (java.util.Date, Calendar and subtypes) is built in, but other APIs might need
      to be supported using this feature.
    </p><p>The following example demonstrates the usage:</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MyEntity {
    <em><span class="hl-annotation" style="color: gray">@QueryType(PropertyType.SIMPLE)</span></em>
    <strong class="hl-keyword">public</strong> String stringAsSimple;

    <em><span class="hl-annotation" style="color: gray">@QueryType(PropertyType.COMPARABLE)</span></em>
    <strong class="hl-keyword">public</strong> String stringAsComparable;

    <em><span class="hl-annotation" style="color: gray">@QueryType(PropertyType.NONE)</span></em>
    <strong class="hl-keyword">public</strong> String stringNotInQuerydsl;
}
</pre><p>The value <code class="code">PropertyType.NONE</code> can be used to skip a property in the
      query type generation. This case is different from @Transient or @QueryTransient
      annotated properties, where properties are not persisted. PropertyType.NONE just
      omits the property from the Querydsl query type.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2529"></a>3.3.4.&nbsp;Delegate methods</h3></div></div></div><p>To declare a static method as a delegate method add the QueryDelegate
      annotation with the corresponding domain type as a value and provide a method
      signature that takes the corresponding Querydsl query type as the first argument.
    </p><p>Here is a simple example from a unit test: </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@QueryEntity</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">class</strong> User {

    String name;

    User manager;

}
</pre><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@QueryDelegate(User.class)</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> BooleanPath isManagedBy(QUser user, User other) {
    <strong class="hl-keyword">return</strong> user.manager.eq(other);
}
</pre><p>And the generated methods in the QUser query type:</p><pre class="programlisting">
<strong class="hl-keyword">public</strong> BooleanPath isManagedBy(QUser other) {
    <strong class="hl-keyword">return</strong> DelegateTest.isManagedBy(<strong class="hl-keyword">this</strong>, other);
}

</pre><p>Delegate methods can also be used to extend built-in types.
      Here are some examples
    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> QueryExtensions {

    <em><span class="hl-annotation" style="color: gray">@QueryDelegate(Date.class)</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> BooleanExpression inPeriod(DatePath&lt;Date&gt; date, Pair&lt;Date,Date&gt; period) {
        <strong class="hl-keyword">return</strong> date.goe(period.getFirst()).and(date.loe(period.getSecond()));
    }

    <em><span class="hl-annotation" style="color: gray">@QueryDelegate(Timestamp.class)</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> BooleanExpression inDatePeriod(DateTimePath&lt;Timestamp&gt; timestamp, Pair&lt;Date,Date&gt; period) {
        Timestamp first = <strong class="hl-keyword">new</strong> Timestamp(DateUtils.truncate(period.getFirst(), Calendar.DAY_OF_MONTH).getTime());
        Calendar second = Calendar.getInstance();
        second.setTime(DateUtils.truncate(period.getSecond(), Calendar.DAY_OF_MONTH));
        second.add(<span class="hl-number">1</span>, Calendar.DAY_OF_MONTH);
        <strong class="hl-keyword">return</strong> timestamp.goe(first).and(timestamp.lt(<strong class="hl-keyword">new</strong> Timestamp(second.getTimeInMillis())));
    }

}
</pre><p>When delegate methods are declared for builtin types then subclasses with the
        proper delegate method usages are created:
    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> QDate <strong class="hl-keyword">extends</strong> DatePath&lt;java.sql.Date&gt; {

    <strong class="hl-keyword">public</strong> QDate(BeanPath&lt;? <strong class="hl-keyword">extends</strong> java.sql.Date&gt; entity) {
        <strong class="hl-keyword">super</strong>(entity.getType(), entity.getMetadata());
    }

    <strong class="hl-keyword">public</strong> QDate(PathMetadata&lt;?&gt; metadata) {
        <strong class="hl-keyword">super</strong>(java.sql.Date.<strong class="hl-keyword">class</strong>, metadata);
    }

    <strong class="hl-keyword">public</strong> BooleanExpression inPeriod(com.mysema.commons.lang.Pair&lt;java.sql.Date, java.sql.Date&gt; period) {
        <strong class="hl-keyword">return</strong> QueryExtensions.inPeriod(<strong class="hl-keyword">this</strong>, period);
    }

}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> QTimestamp <strong class="hl-keyword">extends</strong> DateTimePath&lt;java.sql.Timestamp&gt; {

    <strong class="hl-keyword">public</strong> QTimestamp(BeanPath&lt;? <strong class="hl-keyword">extends</strong> java.sql.Timestamp&gt; entity) {
        <strong class="hl-keyword">super</strong>(entity.getType(), entity.getMetadata());
    }

    <strong class="hl-keyword">public</strong> QTimestamp(PathMetadata&lt;?&gt; metadata) {
        <strong class="hl-keyword">super</strong>(java.sql.Timestamp.<strong class="hl-keyword">class</strong>, metadata);
    }

    <strong class="hl-keyword">public</strong> BooleanExpression inDatePeriod(com.mysema.commons.lang.Pair&lt;java.sql.Date, java.sql.Date&gt; period) {
        <strong class="hl-keyword">return</strong> QueryExtensions.inDatePeriod(<strong class="hl-keyword">this</strong>, period);
    }

}
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2552"></a>3.3.5.&nbsp;Non-annotated types</h3></div></div></div><p>
      It is possible to create Querydsl query types for non annotated types by
      creating <code class="code">@QueryEntities</code> annotations. Just place a QueryEntities annotation into a
      package of your choice and the classes to mirrored in the value attribute.
    </p><p>
      To actually create the types use the <code class="code">com.querydsl.apt.QuerydslAnnotationProcessor</code>.
      In Maven you do it like this:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.mysema.maven<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>apt-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.1.3<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>process<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;outputDirectory&gt;</strong>target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/outputDirectory&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;processor&gt;</strong>com.querydsl.apt.QuerydslAnnotationProcessor<strong class="hl-tag" style="color: #000096">&lt;/processor&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
    ...
  <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2567"></a>3.3.6.&nbsp;Classpath based code generation</h3></div></div></div><p>For cases where annotated Java sources
    are not available, such as the usage of a different JVM
    language such as Scala or Groovy or annotation addition via bytecode manipulation the
    <code class="code">GenericExporter</code> class can be used to scan the classpath for annotated classes and
    generate query types for them.
    </p><p>To make GenericExporter available add a dependency to the querydsl-codegen
      module to your project, or to be more precise
      <code class="code">com.querydsl:querydsl-codegen:${querydsl.version}</code>.
    </p><p>Below is an example for JPA</p><pre class="programlisting">
GenericExporter exporter = <strong class="hl-keyword">new</strong> GenericExporter();
exporter.setKeywords(Keywords.JPA);
exporter.setEntityAnnotation(Entity.<strong class="hl-keyword">class</strong>);
exporter.setEmbeddableAnnotation(Embeddable.<strong class="hl-keyword">class</strong>);
exporter.setEmbeddedAnnotation(Embedded.<strong class="hl-keyword">class</strong>);
exporter.setSupertypeAnnotation(MappedSuperclass.<strong class="hl-keyword">class</strong>);
exporter.setSkipAnnotation(Transient.<strong class="hl-keyword">class</strong>);
exporter.setTargetFolder(<strong class="hl-keyword">new</strong> File(<strong class="hl-string"><em style="color:red">"target/generated-sources/java"</em></strong>));
exporter.export(DomainClass.<strong class="hl-keyword">class</strong>.getPackage());
</pre><p>This will export all the JPA annotated classes in the package of the DomainClass
      class and subpackages to the target/generated-sources/java directory.
    </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2586"></a>3.3.6.1.&nbsp;Usage via Maven</h4></div></div></div><p>The goals generic-export, jpa-export and jdo-export of the querydsl-maven-plugin
        can be used for GenericExporter usage via Maven.
      </p><p>
      The different goals are mapped to the Querydsl, JPA and JDO annotations.
      </p><p>The configuration elements are</p><div class="table"><a name="d0e2595"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Maven configuration</b></p><div class="table-contents"><table class="table" summary="Maven configuration" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col align="left" class="Type"><col align="left" class="Element"><col align="left" class="Descriptions"></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Type</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Element</th><th style="border-bottom: 1px solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">File</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">targetFolder</td><td style="border-bottom: 1px solid ; " align="left">target folder for generated sources</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">boolean</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">scala</td><td style="border-bottom: 1px solid ; " align="left">true, if Scala sources should be generated instead (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">String[]</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">packages</td><td style="border-bottom: 1px solid ; " align="left">packages to be introspected for entity classes</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">boolean</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">handleFields</td><td style="border-bottom: 1px solid ; " align="left">true, if fields should be treated as properties (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">boolean</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">handleMethods</td><td style="border-bottom: 1px solid ; " align="left">true, if getters should be treated as properties (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">String</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">sourceEncoding</td><td style="border-bottom: 1px solid ; " align="left">charset encoding for the generated source files</td></tr><tr><td style="border-right: 1px solid ; " align="left">boolean</td><td style="border-right: 1px solid ; " align="left">testClasspath</td><td style="" align="left">true, if the test classpath should be used instead</td></tr></tbody></table></div></div><br class="table-break"><p>Here is an example for JPA annotated classes</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
      ...
      <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;phase&gt;</strong>process-classes<strong class="hl-tag" style="color: #000096">&lt;/phase&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>jpa-export<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;targetFolder&gt;</strong>target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/targetFolder&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;packages&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;package&gt;</strong>com.example.domain<strong class="hl-tag" style="color: #000096">&lt;/package&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;/packages&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
      ...
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>This will export the JPA annotated classes of the <code class="code">com.example.domain</code> package and
      subpackages to the target/generated-sources/java directory.
      </p><p>If you need to compile the generated sources directly after that, then you can use
      the <code class="code">compile</code> goal for that.</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>compile<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;sourceFolder&gt;</strong>target/generated-sources/scala<strong class="hl-tag" style="color: #000096">&lt;/targetFolder&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
</pre><p>The <code class="code">compile</code> goal has the following configuration elements</p><div class="table"><a name="d0e2681"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Maven configuration</b></p><div class="table-contents"><table class="table" summary="Maven configuration" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col align="left" class="Type"><col align="left" class="Element"><col align="left" class="Descriptions"></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Type</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Element</th><th style="border-bottom: 1px solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">File</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">sourceFolder</td><td style="border-bottom: 1px solid ; " align="left">source folder with generated sources</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">String</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">sourceEncoding</td><td style="border-bottom: 1px solid ; " align="left">charset encoding of sources</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">String</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">source</td><td style="border-bottom: 1px solid ; " align="left">-source option for the compiler</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">String</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">target</td><td style="border-bottom: 1px solid ; " align="left">-target option for the compiler</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">boolean</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">testClasspath</td><td style="border-bottom: 1px solid ; " align="left">true, if the test classpath should be used instead</td></tr><tr><td style="border-right: 1px solid ; " align="left">Map</td><td style="border-right: 1px solid ; " align="left">compilerOptions</td><td style="" align="left">options for the compiler</td></tr></tbody></table></div></div><br class="table-break"><p>All options except <code class="code">sourceFolder</code> are optional.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2744"></a>3.3.6.2.&nbsp;Scala support</h4></div></div></div><p>If you need Scala output of the classes, use a variant of the following
      configuration
      </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
      ...
      <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-scala<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.scala-lang<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>scala-library<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${scala.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>jpa-export<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;targetFolder&gt;</strong>target/generated-sources/scala<strong class="hl-tag" style="color: #000096">&lt;/targetFolder&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;scala&gt;</strong>true<strong class="hl-tag" style="color: #000096">&lt;/scala&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;packages&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;package&gt;</strong>com.example.domain<strong class="hl-tag" style="color: #000096">&lt;/package&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;/packages&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
      ...
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="alias"></a>3.4.&nbsp;Alias usage</h2></div></div></div><p>
    In cases where code generation is not an option, alias objects can be used as path
    references for expression construction. They can be used via proxied Java Bean objects
    through getter method invocations.
  </p><p>
    The following examples demonstrate how alias objects can be used as replacements
    for expression creation based on generated types.
  </p><p>
    At first an example query with APT generated domain types:
  </p><pre class="programlisting">
QCat cat = <strong class="hl-keyword">new</strong> QCat(<strong class="hl-string"><em style="color:red">"cat"</em></strong>);
<strong class="hl-keyword">for</strong> (String name : queryFactory.select(cat.name).from(cat,cats)
    .where(cat.kittens.size().gt(<span class="hl-number">0</span>))
    .fetch()) {
    System.out.println(name);
}
</pre><p>
    And now with an alias instance for the Cat class. The call <code class="code">c.getKittens()</code> inside
    the dollar-method is internally transformed into the property path <code class="code">c.kittens</code>.
  </p><pre class="programlisting">
Cat c = alias(Cat.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"cat"</em></strong>);
<strong class="hl-keyword">for</strong> (String name : select($(c.getName())).from($(c),cats)
    .where($(c.getKittens()).size().gt(<span class="hl-number">0</span>))
    .fetch()) {
    System.out.println(name);
}
</pre><p>
    To use the alias functionality in your code, add the following two
    imports
  </p><pre class="programlisting">
<strong class="hl-keyword">import</strong> <strong class="hl-keyword">static</strong> com.querydsl.core.alias.Alias.$;
<strong class="hl-keyword">import</strong> <strong class="hl-keyword">static</strong> com.querydsl.core.alias.Alias.alias;
</pre><p>
    The following example is a variation of the previous, where the access to the list
    size happens inside the dollar-method invocation.
  </p><pre class="programlisting">
Cat c = alias(Cat.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"cat"</em></strong>);
<strong class="hl-keyword">for</strong> (String name : queryFactory.select($(c.getName())).from($(c),cats)
    .where($(c.getKittens().size()).gt(<span class="hl-number">0</span>))
    .fetch()) {
    System.out.println(name);
}
</pre><p>
    All non-primitive and non-final typed properties of aliases are aliases
    themselves. So you may cascade method calls until you hit a primitive or final type
    in the dollar-method scope. e.g.
  </p><pre class="programlisting">
$(c.getMate().getName())
</pre><p>
    is transformed into *c.mate.name* internally, but
  </p><pre class="programlisting">
$(c.getMate().getName().toLowerCase())
</pre><p>
    is not transformed properly, since the <code class="code">toLowerCase()</code> invocation is not tracked.
  </p><p>
    Note also that you may only invoke getters, size(), contains(Object) and get(int)
    on alias types. All other invocations throw exceptions.
  </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="troubleshooting"></a>4.&nbsp;Troubleshooting</h1></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2798"></a>4.1.&nbsp;Insufficient type arguments</h2></div></div></div><p>
      Querydsl needs properly encoded List Set, Collection and Map properties in all code generation
      scenarios.
    </p><p>When using improperly encoded fields or getters you might the following
      stacktrace:</p><pre class="programlisting">
java.lang.RuntimeException: Caught exception for field com.querydsl.jdo.testdomain.Store#products
  at com.querydsl.apt.Processor$2.visitType(Processor.java:117)
  at com.querydsl.apt.Processor$2.visitType(Processor.java:80)
  at com.sun.tools.javac.code.Symbol$ClassSymbol.accept(Symbol.java:827)
  at com.querydsl.apt.Processor.getClassModel(Processor.java:154)
  at com.querydsl.apt.Processor.process(Processor.java:191)
  ...
Caused by: java.lang.IllegalArgumentException: Insufficient type arguments for List
  at com.querydsl.apt.APTTypeModel.visitDeclared(APTTypeModel.java:112)
  at com.querydsl.apt.APTTypeModel.visitDeclared(APTTypeModel.java:40)
  at com.sun.tools.javac.code.Type$ClassType.accept(Type.java:696)
  at com.querydsl.apt.APTTypeModel.&lt;init&gt;(APTTypeModel.java:55)
  at com.querydsl.apt.APTTypeModel.get(APTTypeModel.java:48)
  at com.querydsl.apt.Processor$2.visitType(Processor.java:114)
  ... 35 more
</pre><p>
      Examples of problematic field declarations and their corrections:
    </p><pre class="programlisting">
    <strong class="hl-keyword">private</strong> Collection names; <em class="hl-comment" style="color: silver">// WRONG</em>

    <strong class="hl-keyword">private</strong> Collection&lt;String&gt; names; <em class="hl-comment" style="color: silver">// RIGHT</em>

    <strong class="hl-keyword">private</strong> Map employeesByName; <em class="hl-comment" style="color: silver">// WRONG</em>

    <strong class="hl-keyword">private</strong> Map&lt;String,Employee&gt; employeesByName; <em class="hl-comment" style="color: silver">// RIGHT</em>
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2811"></a>4.2.&nbsp;Multithreaded initialization of Querydsl Q-types</h2></div></div></div><p>When Querydsl Q-types are initialized from multiple threads, deadlocks can
      occur, if the Q-types have circular dependencies.</p><p>An easy to use solution is to initialize the classes in a single thread before
      they are used in different threads.</p><p>The com.querydsl.codegen.ClassPathUtils class can be used for that like this:</p><pre class="programlisting">
    ClassPathUtils.scanPackage(Thread.currentThread().getContextClassLoader(), packageToLoad);
</pre><p>Replace packageToLoad with the package of the classes you want to initialize.
    </p></div></div></div></body></html>