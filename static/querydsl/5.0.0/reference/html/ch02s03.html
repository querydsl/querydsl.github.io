<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>2.3.&nbsp;Querying SQL</title><link rel="stylesheet" type="text/css" href="css/stylesheet.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Querydsl Reference Guide"><link rel="up" href="ch02.html" title="2.&nbsp;Tutorials"><link rel="prev" href="ch02s02.html" title="2.2.&nbsp;Querying JDO"><link rel="next" href="ch02s04.html" title="2.4.&nbsp;Querydsl Spatial"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.3.&nbsp;Querying SQL</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s02.html">Prev</a>&nbsp;</td><th width="60%" align="center">2.&nbsp;Tutorials</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch02s04.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql_integration"></a>2.3.&nbsp;Querying SQL</h2></div></div></div><p>This chapter describes the query type generation and querying functionality of the
    SQL module.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e731"></a>2.3.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-sql<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-sql-codegen<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>The querydsl-sql-codegen dependency can be skipped, if code generation happens
      via Maven.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e740"></a>2.3.2.&nbsp;Code generation via Maven</h3></div></div></div><p>This functionality should be primarily used via the Maven plugin. Here is an example:
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
      ...
      <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
              <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>export<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcDriver&gt;</strong>org.apache.derby.jdbc.EmbeddedDriver<strong class="hl-tag" style="color: #000096">&lt;/jdbcDriver&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;jdbcUrl&gt;</strong>jdbc:derby:target/demoDB;create=true<strong class="hl-tag" style="color: #000096">&lt;/jdbcUrl&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;packageName&gt;</strong>com.myproject.domain<strong class="hl-tag" style="color: #000096">&lt;/packageName&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;targetFolder&gt;</strong>${project.basedir}/target/generated-sources/java<strong class="hl-tag" style="color: #000096">&lt;/targetFolder&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.derby<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>derby<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${derby.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
          <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
      ...
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre><p>
      Use the goal <span class="emphasis"><em>test-export</em></span>
      to treat the target folder as a test source folder for use with test code.
    </p><div class="table"><a name="d0e752"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Parameters</b></p><div class="table-contents"><table class="table" summary="Parameters" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col align="left" class="Name"><col align="left" class="Descriptions"></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Name</th><th style="border-bottom: 1px solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">jdbcDriver</td><td style="border-bottom: 1px solid ; " align="left">class name of the JDBC driver</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">jdbcUrl</td><td style="border-bottom: 1px solid ; " align="left">JDBC url</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">jdbcUser</td><td style="border-bottom: 1px solid ; " align="left">JDBC user</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">jdbcPassword</td><td style="border-bottom: 1px solid ; " align="left">JDBC password</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">namePrefix</td><td style="border-bottom: 1px solid ; " align="left">name prefix for generated query classes (default: Q)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">nameSuffix</td><td style="border-bottom: 1px solid ; " align="left">name suffix for generated query classes (default: )</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanPrefix</td><td style="border-bottom: 1px solid ; " align="left">name prefix for generated bean classes</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanSuffix</td><td style="border-bottom: 1px solid ; " align="left">name suffix for generated bean classes</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">packageName</td><td style="border-bottom: 1px solid ; " align="left">package name where source files should be generated</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanPackageName</td><td style="border-bottom: 1px solid ; " align="left">package name where bean files should be generated, (default:
              packageName)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanInterfaces</td><td style="border-bottom: 1px solid ; " align="left">array of interface classnames to add to the bean classes (default: empty)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanAddToString</td><td style="border-bottom: 1px solid ; " align="left">set to true to create a default toString() implementation (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanAddFullConstructor</td><td style="border-bottom: 1px solid ; " align="left">set to true to create a full constructor in addition to public empty (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanPrintSupertype</td><td style="border-bottom: 1px solid ; " align="left">set to true to print the supertype as well (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">schemaPattern</td><td style="border-bottom: 1px solid ; " align="left">a schema name pattern in LIKE pattern form; must match the schema name as it is stored in the database,
              multiple can be separated by comma
              (default: null)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">tableNamePattern</td><td style="border-bottom: 1px solid ; " align="left">a table name pattern in LIKE pattern form; must match the table name as it is stored in the database,
              multiple can be separated by comma
              (default: null)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">targetFolder</td><td style="border-bottom: 1px solid ; " align="left">target folder where sources should be generated</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beansTargetFolder</td><td style="border-bottom: 1px solid ; " align="left">target folder where bean sources should be generated, defaults to the same value as targetFolder</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">namingStrategyClass</td><td style="border-bottom: 1px solid ; " align="left">class name of the NamingStrategy class (default: DefaultNamingStrategy)
            </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">beanSerializerClass</td><td style="border-bottom: 1px solid ; " align="left">class name of the BeanSerializer class (default: BeanSerializer)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">serializerClass</td><td style="border-bottom: 1px solid ; " align="left">class name of the Serializer class (default: MetaDataSerializer)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportBeans</td><td style="border-bottom: 1px solid ; " align="left">set to true to generate beans as well, see section 2.14.13 (default:
              false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">innerClassesForKeys</td><td style="border-bottom: 1px solid ; " align="left">set to true to generate inner classes for keys (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">validationAnnotations</td><td style="border-bottom: 1px solid ; " align="left">set to true to enable serialization of validation annotations
              (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">columnAnnotations</td><td style="border-bottom: 1px solid ; " align="left">export column annotations (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">createScalaSources</td><td style="border-bottom: 1px solid ; " align="left">whether to export Scala sources instead of Java sources, (default:
              false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">schemaToPackage</td><td style="border-bottom: 1px solid ; " align="left">append schema name to package (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">lowerCase</td><td style="border-bottom: 1px solid ; " align="left">lower case transformation of names (default: false)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportTables</td><td style="border-bottom: 1px solid ; " align="left">export tables (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportViews</td><td style="border-bottom: 1px solid ; " align="left">export views (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportPrimaryKeys</td><td style="border-bottom: 1px solid ; " align="left">export primary keys (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">tableTypesToExport</td><td style="border-bottom: 1px solid ; " align="left">Comma-separated list of table types to export (allowable values will depend on JDBC driver).  Allows for arbitrary set of types to be exported, e.g.: "TABLE, MATERIALIZED VIEW". The exportTables and exportViews parameters will be ignored if this parameter is set. (default: none)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportForeignKeys</td><td style="border-bottom: 1px solid ; " align="left">export foreign keys (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportDirectForeignKeys</td><td style="border-bottom: 1px solid ; " align="left">export direct foreign keys (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">exportInverseForeignKeys</td><td style="border-bottom: 1px solid ; " align="left">export inverse foreign keys (default: true)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">customTypes</td><td style="border-bottom: 1px solid ; " align="left">Custom user types (default: none)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">typeMappings</td><td style="border-bottom: 1px solid ; " align="left">Mappings of table.column to Java type (default: none)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">numericMappings</td><td style="border-bottom: 1px solid ; " align="left">Mappings of size/digits to Java type (default: none)</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">imports</td><td style="border-bottom: 1px solid ; " align="left">Array of java imports added to generated query classes: <span class="emphasis"><em>com.bar</em></span> for package (without .* notation), <span class="emphasis"><em>com.bar.Foo</em></span> for class (default: empty)</td></tr><tr><td style="border-right: 1px solid ; " align="left">generatedAnnotationClass</td><td style="" align="left">
              The fully qualified class name of the <span class="emphasis"><em>Single-Element Annotation</em></span> (with String element) to be added on the generated sources. Build in
              <span class="emphasis"><em>com.querydsl.core.annotations.Generated</em></span>has CLASS retention which can be used for byte code analysis tools like Jacoco.
              (default: <span class="emphasis"><em>javax.annotation.Generated</em></span> or<span class="emphasis"><em>javax.annotation.processing.Generated</em></span> depending on the java version). See also
              <a class="ulink" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7.3" target="_top">Single-Element Annotation</a>
            </td></tr></tbody></table></div></div><br class="table-break"><p>Custom types can be used to register additional Type implementations:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;customTypes&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;customType&gt;</strong>com.querydsl.sql.types.InputStreamType<strong class="hl-tag" style="color: #000096">&lt;/customType&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/customTypes&gt;</strong>
</pre><p>Type mappings can be used to register table.column specific java types:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;typeMappings&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;typeMapping&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;table&gt;</strong>IMAGE<strong class="hl-tag" style="color: #000096">&lt;/table&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;column&gt;</strong>CONTENTS<strong class="hl-tag" style="color: #000096">&lt;/column&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;type&gt;</strong>java.io.InputStream<strong class="hl-tag" style="color: #000096">&lt;/type&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/typeMapping&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/typeMappings&gt;</strong>
</pre><p>The defaults for the numeric mappings are </p><div class="table"><a name="d0e996"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Numeric mappings</b></p><div class="table-contents"><table class="table" summary="Numeric mappings" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col align="left" class="Name"><col align="left" class="Descriptions"><col></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Total digits</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">Decimal digits</th><th style="border-bottom: 1px solid ; " align="left">Type</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">&gt; 18</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">0</td><td style="border-bottom: 1px solid ; " align="left">BigInteger</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">&gt; 9</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">0</td><td style="border-bottom: 1px solid ; " align="left">Long</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">&gt; 4</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">0</td><td style="border-bottom: 1px solid ; " align="left">Integer</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">&gt; 2</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">0</td><td style="border-bottom: 1px solid ; " align="left">Short</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">&gt; 0</td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left">0</td><td style="border-bottom: 1px solid ; " align="left">Byte</td></tr><tr><td style="border-right: 1px solid ; " align="left">&gt; 0</td><td style="border-right: 1px solid ; " align="left">&gt; 0</td><td style="" align="left">BigDecimal</td></tr></tbody></table></div></div><br class="table-break"><p>They can be customized for specific total/decimal digits combinations like this:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;numericMappings&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;numericMapping&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;total&gt;</strong>1<strong class="hl-tag" style="color: #000096">&lt;/total&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;decimal&gt;</strong>0<strong class="hl-tag" style="color: #000096">&lt;/decimal&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;javaType&gt;</strong>java.lang.Byte<strong class="hl-tag" style="color: #000096">&lt;/javaType&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/numericMapping&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/numericMappings&gt;</strong>
</pre><p>Imports can be used to add cross-schema foreign keys support.</p><p>Schemas, tables and columns can also be renamed using the plugin. Here are some examples:</p><p>Renaming a schema:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;renameMappings&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;renameMapping&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromSchema&gt;</strong>PROD<strong class="hl-tag" style="color: #000096">&lt;/fromSchema&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;toSchema&gt;</strong>TEST<strong class="hl-tag" style="color: #000096">&lt;/toSchema&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/renameMapping&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/renameMappings&gt;</strong>
</pre><p>Renaming a table:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;renameMappings&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;renameMapping&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromSchema&gt;</strong>PROD<strong class="hl-tag" style="color: #000096">&lt;/fromSchema&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromTable&gt;</strong>CUSTOMER<strong class="hl-tag" style="color: #000096">&lt;/fromTable&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;toTable&gt;</strong>CSTMR<strong class="hl-tag" style="color: #000096">&lt;/toTable&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/renameMapping&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/renameMappings&gt;</strong>
</pre><p>Renaming a column:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;renameMappings&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;renameMapping&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromSchema&gt;</strong>PROD<strong class="hl-tag" style="color: #000096">&lt;/fromSchema&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromTable&gt;</strong>CUSTOMER<strong class="hl-tag" style="color: #000096">&lt;/fromTable&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fromColumn&gt;</strong>ID<strong class="hl-tag" style="color: #000096">&lt;/fromColumn&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;toColumn&gt;</strong>IDX<strong class="hl-tag" style="color: #000096">&lt;/toTable&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/renameMapping&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/renameMappings&gt;</strong>
</pre><p>Note: fromSchema can be omitted when renaming tables and columns.</p><p>Compared to APT based code generation certain functionality is not available such as QueryDelegate annotation handling.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1077"></a>2.3.3.&nbsp;Code generation via ANT</h3></div></div></div><p>
      The ANT task <code class="code">com.querydsl.sql.codegen.ant.AntMetaDataExporter</code>
      of the querydsl-sql module provides the same functionality as an ANT task.
      The configuration parameters of the task are the same as for the Maven plugin, except for the composite types.
    </p><p>
      The composite types are used without the wrapper element like in this example.
    </p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;project</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"testproject"</span> <span class="hl-attribute" style="color: #F5844C">default</span>=<span class="hl-value" style="color: #993300">"codegen"</span> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

  <strong class="hl-tag" style="color: #000096">&lt;taskdef</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"codegen"</span> <span class="hl-attribute" style="color: #F5844C">classname</span>=<span class="hl-value" style="color: #993300">"com.querydsl.sql.codegen.ant.AntMetaDataExporter"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>

  <strong class="hl-tag" style="color: #000096">&lt;target</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"codegen"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;codegen</strong>
      <span class="hl-attribute" style="color: #F5844C">jdbcDriver</span>=<span class="hl-value" style="color: #993300">"org.h2.Driver"</span>
      <span class="hl-attribute" style="color: #F5844C">jdbcUser</span>=<span class="hl-value" style="color: #993300">"sa"</span>
      <span class="hl-attribute" style="color: #F5844C">jdbcUrl</span>=<span class="hl-value" style="color: #993300">"jdbc:h2:/dbs/db1"</span>
      <span class="hl-attribute" style="color: #F5844C">packageName</span>=<span class="hl-value" style="color: #993300">"test"</span>
      <span class="hl-attribute" style="color: #F5844C">targetFolder</span>=<span class="hl-value" style="color: #993300">"target/generated-sources/java"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;renameMapping</strong> <span class="hl-attribute" style="color: #F5844C">fromSchema</span>=<span class="hl-value" style="color: #993300">"PUBLIC"</span> <span class="hl-attribute" style="color: #F5844C">toSchema</span>=<span class="hl-value" style="color: #993300">"PUB"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/codegen&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/target&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1089"></a>2.3.4.&nbsp;Creating the query types</h3></div></div></div><p>To get started export your schema into Querydsl query types like this:</p><pre class="programlisting">
java.sql.Connection conn = ...;
MetaDataExporter exporter = <strong class="hl-keyword">new</strong> MetaDataExporter();
exporter.setPackageName(<strong class="hl-string"><em style="color:red">"com.myproject.mydomain"</em></strong>);
exporter.setTargetFolder(<strong class="hl-keyword">new</strong> File(<strong class="hl-string"><em style="color:red">"target/generated-sources/java"</em></strong>));
exporter.export(conn.getMetaData());
</pre><p>This declares that the database schema is to be mirrored into the
      com.myproject.domain package in the target/generated-sources/java folder.
    </p><p>
      The generated types have the table name transformed to mixed case as the class name and a
      similar mixed case transformation applied to the columns which are available as property
      paths in the query type.
    </p><p>
      In addition to this primary key and foreign key constraints are provided as fields
      which can be used for compact join declarations.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1102"></a>2.3.5.&nbsp;Configuration</h3></div></div></div><p>The configuration is done via the com.querydsl.sql.Configuration class which takes
      the
      Querydsl SQL dialect as an argument. For H2 you would create it like this</p><pre class="programlisting">
SQLTemplates templates = <strong class="hl-keyword">new</strong> H2Templates();
Configuration configuration = <strong class="hl-keyword">new</strong> Configuration(templates);
</pre><p>Querydsl uses SQL dialects to customize the SQL serialization needed for
      different relational databases. The available dialects are:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>CUBRIDTemplates (tested with CUBRID 8.4)</p></li><li class="listitem"><p>DB2Templates (tested with DB2 10.1.2)</p></li><li class="listitem"><p>DerbyTemplates (tested with Derby 10.8.2.2)</p></li><li class="listitem"><p>FirebirdTemplates (tested with Firebird 2.5)</p></li><li class="listitem"><p>HSQLDBTemplates (tested with HSQLDB 2.2.4)</p></li><li class="listitem"><p>H2Templates (tested with H2 1.3.164)</p></li><li class="listitem"><p>MySQLTemplates (tested with MySQL 5.5)</p></li><li class="listitem"><p>OracleTemplates (test with Oracle 10 and 11)</p></li><li class="listitem"><p>PostgreSQLTemplates (tested with PostgreSQL 9.1)</p></li><li class="listitem"><p>SQLiteTemplates (tested with xerial JDBC 3.7.2)</p></li><li class="listitem"><p>SQLServerTemplates (tested with SQL Server)</p></li><li class="listitem"><p>SQLServer2005Templates (for SQL Server 2005)</p></li><li class="listitem"><p>SQLServer2008Templates (for SQL Server 2008)</p></li><li class="listitem"><p>SQLServer2012Templates (for SQL Server 2012 and later)</p></li><li class="listitem"><p>TeradataTemplates (tested with Teradata 14)</p></li></ul></div><p>For customized SQLTemplates instances you can use the builder pattern like this</p><pre class="programlisting">
  H2Templates.builder()
     .printSchema() <em class="hl-comment" style="color: silver">// to include the schema in the output</em>
     .quote()       <em class="hl-comment" style="color: silver">// to quote names</em>
     .newLineToSingleSpace() <em class="hl-comment" style="color: silver">// to replace new lines with single space in the output</em>
     .escape(ch)    <em class="hl-comment" style="color: silver">// to set the escape char</em>
     .build();      <em class="hl-comment" style="color: silver">// to get the customized SQLTemplates instance</em>
</pre><p>The methods of the Configuration class can be used to enable direct serialization of literals
    via setUseLiterals(true), override schema and tables and register custom types. For full details look
    at the javadocs of Configuration.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1163"></a>2.3.6.&nbsp;Querying</h3></div></div></div><p>For the following examples we will be using the <code class="code">SQLQueryFactory</code> class for query creation.
      Using it results in more concise code compared to constructor based query creation.</p><pre class="programlisting">
SQLQueryFactory queryFactory = <strong class="hl-keyword">new</strong> SQLQueryFactory(configuration, dataSource);
</pre><p>Querying with Querydsl SQL is as simple as this:</p><pre class="programlisting">
QCustomer customer = <strong class="hl-keyword">new</strong> QCustomer(<strong class="hl-string"><em style="color:red">"c"</em></strong>);

List&lt;String&gt; lastNames = queryFactory.select(customer.lastName).from(customer)
    .where(customer.firstName.eq(<strong class="hl-string"><em style="color:red">"Bob"</em></strong>))
    .fetch();
</pre><p>
      which is transformed into the following sql query, assuming that the related table
      name is <span class="emphasis"><em>customer</em></span>
      and the columns <span class="emphasis"><em>first_name</em></span>
      and <span class="emphasis"><em>last_name</em></span>:
    </p><pre class="programlisting">
SELECT c.last_name
FROM customer c
WHERE c.first_name = 'Bob'
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1190"></a>2.3.7.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the SQLQuery class like this</p><p>
      <span class="emphasis"><em>select:</em></span>
      Set the projection of the query. (Not necessary if created via query factory)
    </p><p>
      <span class="emphasis"><em>from:</em></span>
      Add the query sources here.
    </p><p>
      <span class="emphasis"><em>innerJoin, join, leftJoin, rightJoin, fullJoin, on:</em></span>
      Add join elements using these constructs.
      For the join methods the first argument is the join source and the second the target
      (alias).
    </p><p>
      <span class="emphasis"><em>where:</em></span>
      Add query filters, either in varargs form separated via commas or
      cascaded via the and-operator.
    </p><p>
      <span class="emphasis"><em>groupBy:</em></span>
      Add group by arguments in varargs form.
    </p><p>
      <span class="emphasis"><em>having:</em></span>
      Add having filter of the "group by" grouping as an varags array of
      Predicate expressions.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1235"></a>2.3.8.&nbsp;Joins</h3></div></div></div><p>Joins are constructed using the following syntax:</p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
QCompany company = QCompany.company;
queryFactory.select(customer.firstName, customer.lastName, company.name)
    .from(customer)
    .innerJoin(customer.company, company)
    .fetch();
</pre><p>and for a left join:</p><pre class="programlisting">
queryFactory.select(customer.firstName, customer.lastName, company.name)
    .from(customer)
    .leftJoin(customer.company, company)
    .fetch();
</pre><p>Alternatively the join condition can also be written out:</p><pre class="programlisting">
queryFactory.select(customer.firstName, customer.lastName, company.name)
    .from(customer)
    .leftJoin(company).on(customer.company.eq(company))
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1250"></a>2.3.9.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
queryFactory.select(customer.firstName, customer.lastName)
    .from(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.asc())
    .fetch();
</pre><p>which is equivalent to the following native SQL</p><pre class="programlisting">
SELECT c.first_name, c.last_name
FROM customer c
ORDER BY c.last_name ASC, c.first_name ASC
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1261"></a>2.3.10.&nbsp;Grouping</h3></div></div></div><p>Grouping can be done in the following form</p><pre class="programlisting">
queryFactory.select(customer.lastName)
    .from(customer)
    .groupBy(customer.lastName)
    .fetch();
</pre><p>which is equivalent to the following native SQL</p><pre class="programlisting">
SELECT c.last_name
FROM customer c
GROUP BY c.last_name
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1273"></a>2.3.11.&nbsp;Using Subqueries</h3></div></div></div><p>To create a subquery you can use one of the factory methods of <code class="code">SQLExpressions</code>
      and add the query parameters via from, where etc.
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
QCustomer customer2 = <strong class="hl-keyword">new</strong> QCustomer(<strong class="hl-string"><em style="color:red">"customer2"</em></strong>);
queryFactory.select(customer.all())
    .from(customer)
    .where(customer.status.eq(
        SQLExpressions.select(customer2.status.max()).from(customer2)))
    .fetch()
</pre><p>Another example</p><pre class="programlisting">
QStatus status = QStatus.status;
queryFactory.select(customer.all())
    .from(customer)
    .where(customer.status.in(
        SQLExpressions.select(status.id).from(status).where(status.level.lt(<span class="hl-number">3</span>))))
    .fetch();
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1287"></a>2.3.12.&nbsp;Selecting literals</h3></div></div></div><p>To select literals you need to create constant instances for them like this:</p><pre class="programlisting">
queryFactory.select(Expressions.constant(<span class="hl-number">1</span>),
                    Expressions.constant(<strong class="hl-string"><em style="color:red">"abc"</em></strong>));
</pre><p>The class  <code class="code">com.querydsl.core.types.dsl.Expressions</code> offers also other useful static methods for
    projections, operation and template creation.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1299"></a>2.3.13.&nbsp;Query extension support</h3></div></div></div><p>Custom query extensions to support engine specific syntax can be created by
      subclassing AbstractSQLQuery and adding flagging methods like
      in the given MySQLQuery example:
    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MySQLQuery&lt;T&gt; <strong class="hl-keyword">extends</strong> AbstractSQLQuery&lt;T, MySQLQuery&lt;T&gt;&gt; {

    <strong class="hl-keyword">public</strong> MySQLQuery(Connection conn) {
        <strong class="hl-keyword">this</strong>(conn, <strong class="hl-keyword">new</strong> MySQLTemplates(), <strong class="hl-keyword">new</strong> DefaultQueryMetadata());
    }

    <strong class="hl-keyword">public</strong> MySQLQuery(Connection conn, SQLTemplates templates) {
        <strong class="hl-keyword">this</strong>(conn, templates, <strong class="hl-keyword">new</strong> DefaultQueryMetadata());
    }

    <strong class="hl-keyword">protected</strong> MySQLQuery(Connection conn, SQLTemplates templates, QueryMetadata metadata) {
        <strong class="hl-keyword">super</strong>(conn, <strong class="hl-keyword">new</strong> Configuration(templates), metadata);
    }

    <strong class="hl-keyword">public</strong> MySQLQuery bigResult() {
        <strong class="hl-keyword">return</strong> addFlag(Position.AFTER_SELECT, <strong class="hl-string"><em style="color:red">"SQL_BIG_RESULT "</em></strong>);
    }

    <strong class="hl-keyword">public</strong> MySQLQuery bufferResult() {
        <strong class="hl-keyword">return</strong> addFlag(Position.AFTER_SELECT, <strong class="hl-string"><em style="color:red">"SQL_BUFFER_RESULT "</em></strong>);
    }


    <em class="hl-comment" style="color: silver">// ...</em>
}
</pre><p>
      The flags are custom SQL snippets that can be inserted at specific points in the
      serialization. The supported positions are the enums of the
      <code class="code">com.querydsl.core.QueryFlag.Position</code> enum class.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1311"></a>2.3.14.&nbsp;Window functions</h3></div></div></div><p>Window functions are supported in Querydsl via the methods in the <code class="code">SQLExpressions</code> class.</p><p>Usage example:</p><pre class="programlisting">
queryFactory.select(SQLExpressions.rowNumber()
        .over()
        .partitionBy(employee.name)
        .orderBy(employee.id))
     .from(employee)
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1323"></a>2.3.15.&nbsp;Common table expressions</h3></div></div></div><p>Common table expressions are supported in Querydsl SQL via two syntax variants</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
queryFactory.with(employee, SQLExpressions.select(employee.all)
                                          .from(employee)
                                          .where(employee.name.startsWith(<strong class="hl-string"><em style="color:red">"A"</em></strong>)))
            .from(...)
</pre><p>And using a column listing</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
queryFactory.with(employee, employee.id, employee.name)
            .as(SQLExpressions.select(employee.id, employee.name)
                              .from(employee)
                              .where(employee.name.startsWith(<strong class="hl-string"><em style="color:red">"A"</em></strong>)))
            .from(...)
</pre><p>If the columns of the common table expression are a subset of an existing table or view
    it is advisable to use a generated path type for it, e.g. QEmployee in this case, but if the
    columns don't fit any existing table PathBuilder can be used instead.</p><p>Below is an example for such a case</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
QDepartment department = QDepartment.department;
PathBuilder&lt;Tuple&gt; emp = <strong class="hl-keyword">new</strong> PathBuilder&lt;Tuple&gt;(Tuple.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"emp"</em></strong>);
queryFactory.with(emp, SQLExpressions.select(employee.id, employee.name, employee.departmentId,
                                          department.name.as(<strong class="hl-string"><em style="color:red">"departmentName"</em></strong>))
                                      .from(employee)
                                      .innerJoin(department).on(employee.departmentId.eq(department.id))))
            .from(...)
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1340"></a>2.3.16.&nbsp;Other SQL expressions</h3></div></div></div><p>
    Other SQL expressions are also available from the <code class="code">SQLExpressions</code> class as static methods.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1348"></a>2.3.17.&nbsp;Using Data manipulation commands</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1351"></a>2.3.17.1.&nbsp;Insert</h4></div></div></div><p>With columns</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.insert(survey)
    .columns(survey.id, survey.name)
    .values(<span class="hl-number">3</span>, <strong class="hl-string"><em style="color:red">"Hello"</em></strong>).execute();
</pre><p>Without columns</p><pre class="programlisting">
queryFactory.insert(survey)
    .values(<span class="hl-number">4</span>, <strong class="hl-string"><em style="color:red">"Hello"</em></strong>).execute();
</pre><p>With subquery</p><pre class="programlisting">
queryFactory.insert(survey)
    .columns(survey.id, survey.name)
    .select(SQLExpressions.select(survey2.id.add(<span class="hl-number">1</span>), survey2.name).from(survey2))
    .execute();
</pre><p>With subquery, without columns</p><pre class="programlisting">
queryFactory.insert(survey)
    .select(SQLExpressions.select(survey2.id.add(<span class="hl-number">10</span>), survey2.name).from(survey2))
    .execute();
</pre><p>As an alternative to the columns/values usage, Querydsl provides also a set
     method which can be used like this</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.insert(survey)
    .set(survey.id, <span class="hl-number">3</span>)
    .set(survey.name, <strong class="hl-string"><em style="color:red">"Hello"</em></strong>).execute();
</pre><p>which is equivalent to the first example. Usage of the set method always
     expands internally to columns and values.</p><p>Beware that</p><pre class="programlisting">
columns(...).select(...)
</pre><p>maps the result set of the given query to be inserted whereas</p><p>To get the created keys out instead of modified rows count use one of the executeWithKey/s method.</p><pre class="programlisting">
set(...)
</pre><p>maps single columns and nulls are used for empty subquery results.</p><p>To populate a clause instance based on the contents of a bean you can use</p><pre class="programlisting">
queryFactory.insert(survey)
    .populate(surveyBean).execute();
</pre><p>This will exclude null bindings, if you need also null bindings use</p><pre class="programlisting">
queryFactory.insert(survey)
    .populate(surveyBean, DefaultMapper.WITH_NULL_BINDINGS).execute();
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1396"></a>2.3.17.2.&nbsp;Update</h4></div></div></div><p>With where</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.update(survey)
    .where(survey.name.eq(<strong class="hl-string"><em style="color:red">"XXX"</em></strong>))
    .set(survey.name, <strong class="hl-string"><em style="color:red">"S"</em></strong>)
    .execute();
</pre><p>Without where</p><pre class="programlisting">
queryFactory.update(survey)
    .set(survey.name, <strong class="hl-string"><em style="color:red">"S"</em></strong>)
    .execute();
</pre><p>Using bean population</p><pre class="programlisting">
queryFactory.update(survey)
    .populate(surveyBean)
    .execute();
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1411"></a>2.3.17.3.&nbsp;Delete</h4></div></div></div><p>With where</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.delete(survey)
    .where(survey.name.eq(<strong class="hl-string"><em style="color:red">"XXX"</em></strong>))
    .execute();

</pre><p>Without where</p><pre class="programlisting">
queryFactory.delete(survey)
    .execute()
</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1422"></a>2.3.18.&nbsp;Batch support in DML clauses</h3></div></div></div><p>Querydsl SQL supports usage of JDBC batch updates through the DML APIs. If you
      have consecutive DML calls with a similar structure,
      you can bundle the the calls via addBatch() usage into one DMLClause. See the examples how
      it works for UPDATE, DELETE and INSERT.
    </p><p>Update:</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.insert(survey).values(<span class="hl-number">2</span>, <strong class="hl-string"><em style="color:red">"A"</em></strong>).execute();
queryFactory.insert(survey).values(<span class="hl-number">3</span>, <strong class="hl-string"><em style="color:red">"B"</em></strong>).execute();

SQLUpdateClause update = queryFactory.update(survey);
update.set(survey.name, <strong class="hl-string"><em style="color:red">"AA"</em></strong>).where(survey.name.eq(<strong class="hl-string"><em style="color:red">"A"</em></strong>)).addBatch();
update.set(survey.name, <strong class="hl-string"><em style="color:red">"BB"</em></strong>).where(survey.name.eq(<strong class="hl-string"><em style="color:red">"B"</em></strong>)).addBatch();
</pre><p>Delete:</p><pre class="programlisting">
queryFactory.insert(survey).values(<span class="hl-number">2</span>, <strong class="hl-string"><em style="color:red">"A"</em></strong>).execute();
queryFactory.insert(survey).values(<span class="hl-number">3</span>, <strong class="hl-string"><em style="color:red">"B"</em></strong>).execute();

SQLDeleteClause delete = queryFactory.delete(survey);
delete.where(survey.name.eq(<strong class="hl-string"><em style="color:red">"A"</em></strong>)).addBatch();
delete.where(survey.name.eq(<strong class="hl-string"><em style="color:red">"B"</em></strong>)).addBatch();
assertEquals(<span class="hl-number">2</span>, delete.execute());
</pre><p>Insert:</p><pre class="programlisting">
SQLInsertClause insert = queryFactory.insert(survey);
insert.set(survey.id, <span class="hl-number">5</span>).set(survey.name, <strong class="hl-string"><em style="color:red">"5"</em></strong>).addBatch();
insert.set(survey.id, <span class="hl-number">6</span>).set(survey.name, <strong class="hl-string"><em style="color:red">"6"</em></strong>).addBatch();
assertEquals(<span class="hl-number">2</span>, insert.execute());
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1439"></a>2.3.19.&nbsp;Bean class generation</h3></div></div></div><p>To create JavaBean DTO types for the tables of your schema use the
      MetaDataExporter like this:</p><pre class="programlisting">
java.sql.Connection conn = ...;
MetaDataExporter exporter = <strong class="hl-keyword">new</strong> MetaDataExporter();
exporter.setPackageName(<strong class="hl-string"><em style="color:red">"com.myproject.mydomain"</em></strong>);
exporter.setTargetFolder(<strong class="hl-keyword">new</strong> File(<strong class="hl-string"><em style="color:red">"src/main/java"</em></strong>));
exporter.setBeanSerializer(<strong class="hl-keyword">new</strong> BeanSerializer());
exporter.export(conn.getMetaData());
</pre><p>Now you can use the bean types as arguments to the populate method in DML
      clauses and you can project directly
      to bean types in queries. Here is a simple example in JUnit form:
    </p><pre class="programlisting">
QEmployee e = <strong class="hl-keyword">new</strong> QEmployee(<strong class="hl-string"><em style="color:red">"e"</em></strong>);

<em class="hl-comment" style="color: silver">// Insert</em>
Employee employee = <strong class="hl-keyword">new</strong> Employee();
employee.setFirstname(<strong class="hl-string"><em style="color:red">"John"</em></strong>);
Integer id = queryFactory.insert(e).populate(employee).executeWithKey(e.id);
employee.setId(id);

<em class="hl-comment" style="color: silver">// Update</em>
employee.setLastname(<strong class="hl-string"><em style="color:red">"Smith"</em></strong>);
assertEquals(<span class="hl-number">1l</span>, queryFactory.update(e).populate(employee).where(e.id.eq(employee.getId())).execute());

<em class="hl-comment" style="color: silver">// Query</em>
Employee smith = queryFactory.selectFrom(e).where(e.lastname.eq(<strong class="hl-string"><em style="color:red">"Smith"</em></strong>)).fetchOne();
assertEquals(<strong class="hl-string"><em style="color:red">"John"</em></strong>, smith.getFirstname());

<em class="hl-comment" style="color: silver">// Delete</em>
assertEquals(<span class="hl-number">1l</span>, queryFactory.delete(e).where(e.id.eq(employee.getId())).execute());
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1451"></a>2.3.20.&nbsp;Extracting the SQL query and bindings</h3></div></div></div><p>The SQL query and bindings can be extracted via the getSQL method:</p><pre class="programlisting">
SQLBindings bindings = query.getSQL();
System.out.println(bindings.getSQL());
</pre><p>If you need also all literals in the SQL string you can enable literal serialization on the
   query or configuration level via setUseLiterals(true).</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1460"></a>2.3.21.&nbsp;Custom types</h3></div></div></div><p>Querydsl SQL provides the possibility to declare custom type mappings for
      ResultSet/Statement interaction. The custom type mappings can be
      declared in com.querydsl.sql.Configuration instances, which are supplied as constructor
      arguments to the actual queries:
    </p><pre class="programlisting">
Configuration configuration = <strong class="hl-keyword">new</strong> Configuration(<strong class="hl-keyword">new</strong> H2Templates());
<em class="hl-comment" style="color: silver">// overrides the mapping for Types.DATE</em>
configuration.register(<strong class="hl-keyword">new</strong> UtilDateType());
</pre><p>And for a table column</p><pre class="programlisting">
Configuration configuration = <strong class="hl-keyword">new</strong> Configuration(<strong class="hl-keyword">new</strong> H2Templates());
<em class="hl-comment" style="color: silver">// declares a mapping for the gender column in the person table</em>
configuration.register(<strong class="hl-string"><em style="color:red">"person"</em></strong>, <strong class="hl-string"><em style="color:red">"gender"</em></strong>,  <strong class="hl-keyword">new</strong> EnumByNameType&lt;Gender&gt;(Gender.<strong class="hl-keyword">class</strong>));
</pre><p>To customize a numeric mapping you can use the registerNumeric method like this
    </p><pre class="programlisting">
configuration.registerNumeric(<span class="hl-number">5</span>,<span class="hl-number">2</span>,Float.<strong class="hl-keyword">class</strong>);
</pre><p>This will map the Float type to the NUMERIC(5,2) type.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1477"></a>2.3.22.&nbsp;Listening to queries and clauses</h3></div></div></div><p>SQLListener is a listener interface that can be used to listen to queries and DML clause. SQLListener
    instances can be registered either on the configuration and on the query/clause level via the addListener method.</p><p>Use cases for listeners are data synchronization, logging, caching and validation.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1484"></a>2.3.23.&nbsp;Spring integration</h3></div></div></div><p>Querydsl SQL integrates with Spring through the querydsl-sql-spring module:</p><pre class="programlisting">
<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.querydsl<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>querydsl-sql-spring<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${querydsl.version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
</pre><p>It provides Spring exception translation and a Spring connection provider for usage of Querydsl SQL
    with Spring transaction managers. Below is a configuration example:</p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.querydsl.example.config;

<strong class="hl-keyword">import</strong> com.querydsl.sql.H2Templates;
<strong class="hl-keyword">import</strong> com.querydsl.sql.SQLQueryFactory;
<strong class="hl-keyword">import</strong> com.querydsl.sql.SQLTemplates;
<strong class="hl-keyword">import</strong> com.querydsl.sql.spring.SpringConnectionProvider;
<strong class="hl-keyword">import</strong> com.querydsl.sql.spring.SpringExceptionTranslator;
<strong class="hl-keyword">import</strong> com.querydsl.sql.types.DateTimeType;
<strong class="hl-keyword">import</strong> com.querydsl.sql.types.LocalDateType;
<strong class="hl-keyword">import</strong> org.springframework.context.annotation.Bean;
<strong class="hl-keyword">import</strong> org.springframework.context.annotation.Configuration;
<strong class="hl-keyword">import</strong> org.springframework.context.annotation.PropertySource;
<strong class="hl-keyword">import</strong> org.springframework.core.env.Environment;
<strong class="hl-keyword">import</strong> org.springframework.jdbc.datasource.DataSourceTransactionManager;
<strong class="hl-keyword">import</strong> org.springframework.transaction.PlatformTransactionManager;

<strong class="hl-keyword">import</strong> javax.sql.DataSource;
<strong class="hl-keyword">import</strong> java.sql.Connection;

<em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> JdbcConfiguration {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <strong class="hl-keyword">public</strong> DataSource dataSource() {
        <em class="hl-comment" style="color: silver">// implementation omitted</em>
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <strong class="hl-keyword">public</strong> PlatformTransactionManager transactionManager() {
        <strong class="hl-keyword">return</strong> <strong class="hl-keyword">new</strong> DataSourceTransactionManager(dataSource());
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <strong class="hl-keyword">public</strong> com.querydsl.sql.Configuration querydslConfiguration() {
        SQLTemplates templates = H2Templates.builder().build(); <em class="hl-comment" style="color: silver">//change to your Templates</em>
        com.querydsl.sql.Configuration configuration = <strong class="hl-keyword">new</strong> com.querydsl.sql.Configuration(templates);
        configuration.setExceptionTranslator(<strong class="hl-keyword">new</strong> SpringExceptionTranslator());
        <strong class="hl-keyword">return</strong> configuration;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <strong class="hl-keyword">public</strong> SQLQueryFactory queryFactory() {
        SpringConnectionProvider provider = <strong class="hl-keyword">new</strong> SpringConnectionProvider(dataSource());
        <strong class="hl-keyword">return</strong> <strong class="hl-keyword">new</strong> SQLQueryFactory(querydslConfiguration(), provider);
    }

}
</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s02.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch02s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2.2.&nbsp;Querying JDO&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;2.4.&nbsp;Querydsl Spatial</td></tr></table></div></body></html>